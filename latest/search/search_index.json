{
    "docs": [
        {
            "location": "/", 
            "text": "Phylo\n\n\nPackage for creating and manipulating phylogenies\n\n\nPhylo\n is a \nJulia\n package that provides  functionality for generating phylogenetic trees to feed into our  \nDiversity\n package to calculate phylogenetic  diversity (currently on master, accessible via \nPkg.checkout()\n,  but not released). Both are currently under development, so please  \nraise an issue\n if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from \nDistributions\n. For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:\n\n\njulia\n \nusing\n \nPhylo\n\n\n\njulia\n \nnu\n \n=\n \nNonultrametric\n(\n5\n);\n\n\n\njulia\n \ntree\n \n=\n \nrand\n(\nnu\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n9\n \nnodes\n \nand\n \n8\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\ntip 1\n,\n \ntip 2\n,\n \ntip 3\n,\n \ntip 4\n,\n \ntip 5\n]\n\n\n\n\n\n\nThe code also provides iterators, and filtered iterators over the branches, nodes, branchnames and nodenames of a tree:\n\n\njulia\n \ncollect\n(\nnodeiter\n(\ntree\n))\n\n\n9\n-\nelement\n \nArray\n{\nPhylo\n.\nBinaryNode\n{\nInt64\n},\n1\n}\n:\n\n \n[\nbranch\n \n4\n]\n--\n[\nleaf\n \nnode\n]\n\n \n[\nbranch\n \n5\n]\n--\n[\nleaf\n \nnode\n]\n\n \n[\nbranch\n \n2\n]\n--\n[\nleaf\n \nnode\n]\n\n \n[\nbranch\n \n1\n]\n--\n[\nleaf\n \nnode\n]\n\n \n[\nbranch\n \n8\n]\n--\n[\nleaf\n \nnode\n]\n\n \n[\nbranch\n \n3\n]\n--\n[\ninternal\n \nnode\n]\n--\n[\nbranches\n \n1\n \nand\n \n2\n]\n\n \n[\nbranch\n \n6\n]\n--\n[\ninternal\n \nnode\n]\n--\n[\nbranches\n \n3\n \nand\n \n4\n]\n\n \n[\nbranch\n \n7\n]\n--\n[\ninternal\n \nnode\n]\n--\n[\nbranches\n \n5\n \nand\n \n6\n]\n\n \n[\nroot\n \nnode\n]\n--\n[\nbranches\n \n7\n \nand\n \n8\n]\n\n\n\njulia\n \ncollect\n(\nnodenamefilter\n(\nisroot\n,\n \ntree\n))\n\n\n1\n-\nelement\n \nArray\n{\nString\n,\n1\n}\n:\n\n \nNode 4\n\n\n\n\n\n\nThe current main purpose of this package is to provide a framework for phylogenetics to use in our \nDiversity\n package, and they will both be adapted as appropriate until both are functioning as required (though they are currently working together reasonably successfully).\n\n\nHowever, it can also read newick trees:\n\n\njulia\n \nusing\n \nPhylo\n\n\n\njulia\n \nsimpletree\n \n=\n \nparsenewick\n(\n((,Tip:1.0)Internal,)Root;\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n5\n \nnodes\n \nand\n \n4\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\nNode 2\n,\n \nTip\n,\n \nNode 1\n]\n\n\n\njulia\n \ngetbranches\n(\nsimpletree\n)\n\n\nDict\n{\nInt64\n,\nPhylo\n.\nBranch\n{\nString\n}}\n \nwith\n \n4\n \nentries\n:\n\n  \n4\n \n=\n \n[\nnode\n \nRoot\n]\n--\n[\nNaN\n \nlength\n \nbranch\n]\n--\n[\nnode\n \nNode 2\n]\n\n  \n2\n \n=\n \n[\nnode\n \nInternal\n]\n--\n[\n1.0\n \nlength\n \nbranch\n]\n--\n[\nnode\n \nTip\n]\n\n  \n3\n \n=\n \n[\nnode\n \nRoot\n]\n--\n[\nNaN\n \nlength\n \nbranch\n]\n--\n[\nnode\n \nInternal\n]\n\n  \n1\n \n=\n \n[\nnode\n \nInternal\n]\n--\n[\nNaN\n \nlength\n \nbranch\n]\n--\n[\nnode\n \nNode 1\n]\n\n\n\njulia\n \nopen\n(\nparsenewick\n,\n \ntree\n \n=\n \nopen\n(\nparsenewick\n,\n \nPkg\n.\ndir\n(\nPhylo\n,\n \ntest\n,\n \nh1n1.trees\n)))\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n1013\n \nnodes\n \nand\n \n1012\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\n407\n,\n \n153\n,\n \n1\n,\n \n54\n,\n \n101\n,\n \n371\n,\n \n41\n,\n \n464\n,\n \n65\n,\n \n475\n  \n\u2026\n  \n336\n,\n \n145\n,\n \n36\n,\n \n95\n,\n \n414\n,\n \n138\n,\n \n294\n,\n \n353\n,\n \n232\n,\n \n306\n]\n\n\n\n\n\n\nAnd while we wait for me (or kind \ncontributors\n!) to fill out the other extensive functionality that many phylogenetics packages have in other languages, the other important feature that it offers is a fully(?)-functional interface to R, allowing any existing R library functions to be carried out on julia trees, and trees to be read from disk and written using R helper functions. Naturally the medium-term plan is to fill in as many of these gaps as possible in Julia, and as a result this R interface is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, if you want to use the R interface you need to do it manually, as below:\n\n\njulia\n \nusing\n \nRCall\n\n\n\njulia\n \ninclude\n(\njoinpath\n(\nPkg\n.\ndir\n(\nPhylo\n),\n \nsrc\n,\n \nrcall.jl\n));\n\n\n\nR\n \nlibrary\n(\nape\n)\n\n\n\n\n\n\nYou can then translate back and forth using \nNamedTree\n contructors on R \nphylo\n objects, and \nRObject\n constructors on julia \nNamedTree\n types to keep them in Julia or \n@rput\n to move the object into R:\n\n\njulia\n \nrt\n \n=\n \nrcall\n(\n:\nrtree\n,\n \n10\n)\n\n\nRCall\n.\nRObject\n{\nRCall\n.\nVecSxp\n}\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\njulia\n \njt\n \n=\n \nNamedTree\n(\nrt\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n19\n \nnodes\n \nand\n \n18\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \nt3\n,\n \nt4\n,\n \nt7\n,\n \nt9\n]\n\n\n\njulia\n \n@rput\n \nrt\n;\n\n\n\njulia\n \n@rput\n \njt\n;\n \n# Automatically translates jt back to R\n\n\n\nR\n \njt\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\nR\n \nall\n.\nequal\n(\nrt\n,\n \njt\n)\n \n# check no damage in translations\n\n\n[\n1\n]\n \nTRUE\n\n\n\n\n\n\n\n\nPhylo\n\n\n\n\n#\n\n\nPhylo\n \n \nModule\n.\n\n\nPhylo package\n\n\n\n\n\nThe \nPhylo\n package provides a standard abstract interface to phylogenetic trees, by defining \nAbstractNode\n, \nAbstractBranch\n and \nAbstractTree\n supertypes, and methods to interface to them. It also provides (through the \nPhylo.API\n submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryNode\n \n \nType\n.\n\n\nBinaryNode{T}(AbstractVector{T}, AbstractVector{T}) \n: AbstractNode\n\n\n\n\n\nA node of strict binary phylogenetic tree\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryTree\n \n \nType\n.\n\n\nBinaryTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves and per node data\n\n\nsource\n\n\n#\n\n\nPhylo.Branch\n \n \nType\n.\n\n\nBranch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.NamedPolytomousTree\n \n \nType\n.\n\n\nNamedPolytomousTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves\n\n\nsource\n\n\n#\n\n\nPhylo.NamedTree\n \n \nType\n.\n\n\nNamedBinaryTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves\n\n\nsource\n\n\n#\n\n\nPhylo.Node\n \n \nType\n.\n\n\nNode{T}(AbstractVector{T}, AbstractVector{T}) \n: AbstractNode\n\n\n\n\n\nA node of potentially polytomous phylogenetic tree\n\n\nsource\n\n\n#\n\n\nPhylo.Nonultrametric\n \n \nType\n.\n\n\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(n::Int,\n                                  rng::RNG = Exponential())\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(tiplabels::Vector{String},\n                                  rng::RNG = Exponential())\n\n\n\n\n\nThe sampler for non-ultrametric phylogenetic trees of size \nn\n or with tip labels \ntiplabels\n. Generate random trees by calling rand(). Currently only works for \nNamedTree\ns.\n\n\nsource\n\n\n#\n\n\nPhylo.PolytomousTree\n \n \nType\n.\n\n\nPolytomousTree\n\n\n\n\n\nPhylogenetic tree object with polytomous branching, and known leaves and per node data\n\n\nsource\n\n\n#\n\n\nPhylo.Ultrametric\n \n \nType\n.\n\n\nUltrametric{T \n: AbstractTree,\n            RNG \n: Sampleable}(n::Int,\n                               rng::RNG = Exponential())\nUltrametric{T \n: AbstractTree,\n            RNG \n: Sampleable}(tiplabels::Vector{String},\n                               rng::RNG = Exponential())\n\n\n\n\n\nThe sampler for ultrametric phylogenetic trees of size \nn\n or with tip labels \ntiplabels\n. Generate random trees by calling rand(). Currently only works for \nNamedTree\ns.\n\n\nsource\n\n\n#\n\n\nPhylo.addbranch!\n \n \nFunction\n.\n\n\naddbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n,\n \ndestination\n[\n,\n \nlength\n::Float64\n]\n;\n\n           \nbranchname\n \n=\n \n_newbranchlabel\n(\ntree\n))\n\n\n\n\n\n\nAdd a branch from \nsource\n to \ndestination\n on \ntree\n.\n\n\nsource\n\n\n#\n\n\nPhylo.addnode!\n \n \nFunction\n.\n\n\naddnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.addnodes!\n \n \nFunction\n.\n\n\naddnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.branch!\n \n \nFunction\n.\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n)\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n;\n \ndestination\n)\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n;\n \ndestination\n,\n \nbranchname\n)\n\n\n\n\n\n\nBranch from a source node \nsource\n and create a destination node \ndestination\n.\n\n\nsource\n\n\n#\n\n\nPhylo.branchfilter\n \n \nMethod\n.\n\n\nbranchfilter(filterfn::Function, tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the branches of any tree, where the \nAbstractBranch\n is filtered by the function \nfilterfn\n.\n\n\nsource\n\n\n#\n\n\nPhylo.branchhistory\n \n \nMethod\n.\n\n\nbranchhistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the branch route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.branchiter\n \n \nMethod\n.\n\n\nbranchiter(tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the branches of any tree.\n\n\nsource\n\n\n#\n\n\nPhylo.branchnamefilter\n \n \nMethod\n.\n\n\nbranchnamefilter(filterfn::Function, tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the names of the branches of any tree, where the \nAbstractBranch\n is filtered by the function \nfilterfn\n.\n\n\nsource\n\n\n#\n\n\nPhylo.branchnameiter\n \n \nMethod\n.\n\n\nbranchnameiter(tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the names of branches of any tree.\n\n\nsource\n\n\n#\n\n\nPhylo.branchnametype\n \n \nMethod\n.\n\n\nbranchnametype(::AbstractTree)\n\n\n\n\n\nReturns type of branch names.\n\n\nsource\n\n\n#\n\n\nPhylo.branchroute\n \n \nMethod\n.\n\n\nbranchroute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the branch route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.branchtype\n \n \nMethod\n.\n\n\nbranchtype(tree::AbstractTree)\n\n\n\n\n\nReturns type of branches in a tree.\n\n\nsource\n\n\n#\n\n\nPhylo.changedst!\n \n \nMethod\n.\n\n\nchangedst!(tree::AbstractTree, branchname, destination)\n\n\n\n\n\nChange the destination node for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.changesrc!\n \n \nMethod\n.\n\n\nchangesrc!(tree::AbstractTree, branchname, source)\n\n\n\n\n\nChange the source node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.clearrootheight!\n \n \nMethod\n.\n\n\nclearrootheight(::AbstractTree)\n\n\n\n\n\nClears the tree's root height record.\n\n\nsource\n\n\n#\n\n\nPhylo.deletebranch!\n \n \nMethod\n.\n\n\ndeletebranch!(tree::AbstractTree, branchname)\n\n\n\n\n\nDelete the branch \nbranchname\n from \ntree\n.\n\n\nsource\n\n\n#\n\n\nPhylo.deletenode!\n \n \nMethod\n.\n\n\ndeletenode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.distance\n \n \nMethod\n.\n\n\ndistance(tree::AbstractTree, node1, node2)\n\n\n\n\n\nDistance between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.distances\n \n \nMethod\n.\n\n\ndistances(tree::AbstractTree)\n\n\n\n\n\nPairwise distances between all leaf nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.droptips!\n \n \nMethod\n.\n\n\ndroptips!(t::T, tips::Vector{NL}) where {NL, BL, T \n: AbstractTree{NL, BL}}\n\n\n\n\n\nFunction to drop tips from a phylogenetic tree \nt\n, which are found in the vector of tip names, \ntips\n.\n\n\nsource\n\n\n#\n\n\nPhylo.dst\n \n \nFunction\n.\n\n\ndst(branch::AbstractBranch)\ndst(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the destination node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.getancestors\n \n \nMethod\n.\n\n\ngetancestors(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name of all of the nodes that are ancestral to this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getbranch\n \n \nMethod\n.\n\n\ngetbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getbranchnames\n \n \nMethod\n.\n\n\ngetbranchnames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getchildren\n \n \nMethod\n.\n\n\ngetchildren(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name(s) of the child node(s) for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getdescendants\n \n \nMethod\n.\n\n\ngetdescendants(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the names of all of the nodes that descend from this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getheight\n \n \nMethod\n.\n\n\ngetheight(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the height of the node.\n\n\nsource\n\n\n#\n\n\nPhylo.getinbound\n \n \nFunction\n.\n\n\ngetinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nreturn the name of the inbound branch to this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getleafinfo\n \n \nMethod\n.\n\n\ngetleafinfo(::AbstractTree, label)\n\n\n\n\n\nretrieve the leaf info for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getleafnames\n \n \nMethod\n.\n\n\ngetleafnames(::AbstractTree)\n\n\n\n\n\nRetrieve the leaf names from the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getlength\n \n \nFunction\n.\n\n\ngetlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the length of this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.getnode\n \n \nMethod\n.\n\n\ngetnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnodenames\n \n \nMethod\n.\n\n\ngetnodenames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnoderecord\n \n \nMethod\n.\n\n\ngetnoderecord(::AbstractTree, label)\n\n\n\n\n\nretrieve the node record for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getoutbounds\n \n \nFunction\n.\n\n\ngetoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the names of the outbound branches from this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getparent\n \n \nMethod\n.\n\n\ngetparent(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name of the parent node for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getrootheight\n \n \nMethod\n.\n\n\ngetrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasbranch\n \n \nMethod\n.\n\n\nhasbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasheight\n \n \nFunction\n.\n\n\nhasheight(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have a height defined?\n\n\nsource\n\n\n#\n\n\nPhylo.hasinbound\n \n \nFunction\n.\n\n\nhasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have an inbound connection?\n\n\nsource\n\n\n#\n\n\nPhylo.hasinboundspace\n \n \nFunction\n.\n\n\nhasinboundspace(node::AbstractNode)\nhasinboundspace(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have space for an inbound connection?\n\n\nsource\n\n\n#\n\n\nPhylo.hasnode\n \n \nMethod\n.\n\n\nhasnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasoutboundspace\n \n \nFunction\n.\n\n\nhasoutboundspace(node::AbstractNode)\nhasoutboundspace(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have space for an[other] outbound connection?\n\n\nsource\n\n\n#\n\n\nPhylo.hasrootheight\n \n \nMethod\n.\n\n\nhasrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.heightstoroot\n \n \nMethod\n.\n\n\nheights(tree::AbstractTree)\n\n\n\n\n\nHeight of all of the leaves of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.heighttoroot\n \n \nMethod\n.\n\n\nheight(tree::AbstractTree, node)\n\n\n\n\n\nHeight of a node of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.indegree\n \n \nFunction\n.\n\n\nindegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isinternal\n \n \nFunction\n.\n\n\nisinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isleaf\n \n \nFunction\n.\n\n\nisleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isroot\n \n \nFunction\n.\n\n\nisroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isunattached\n \n \nFunction\n.\n\n\nisunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.keeptips!\n \n \nMethod\n.\n\n\nkeeptips!(t::T, tips::Vector{NL}) where {NL, BL, T \n: AbstractTree{NL, BL}}\n\n\n\n\n\nFunction to keep only the tips in a phylogenetic tree, \nt\n, that are found in the vector of tip names, \ntip\n.\n\n\nsource\n\n\n#\n\n\nPhylo.nodefilter\n \n \nMethod\n.\n\n\nnodefilter(filterfn::Function, tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the nodes of any tree, where the \nAbstractNode\n is filtered by the function \nfilterfn\n.\n\n\nsource\n\n\n#\n\n\nPhylo.nodehistory\n \n \nMethod\n.\n\n\nnodehistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the node route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.nodeiter\n \n \nMethod\n.\n\n\nnodeiter(tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the nodes of any tree.\n\n\nsource\n\n\n#\n\n\nPhylo.nodenamefilter\n \n \nMethod\n.\n\n\nnodenamefilter(filterfn::Function, tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the nodenames of any tree, where the \nAbstractNode\n itself is filtered by the function \nfilterfn\n.\n\n\nsource\n\n\n#\n\n\nPhylo.nodenameiter\n \n \nMethod\n.\n\n\nnodenameiter(tree::AbstractTree)\n\n\n\n\n\nReturns an iterator over the names of the nodes of any tree.\n\n\nsource\n\n\n#\n\n\nPhylo.nodenametype\n \n \nMethod\n.\n\n\nnodenametype(::AbstractTree)\n\n\n\n\n\nReturns type of node names.\n\n\nsource\n\n\n#\n\n\nPhylo.noderoute\n \n \nMethod\n.\n\n\nnoderoute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the node route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.nodetype\n \n \nMethod\n.\n\n\nnodetype(tree::AbstractTree)\n\n\n\n\n\nReturns type of nodes in a tree.\n\n\nsource\n\n\n#\n\n\nPhylo.outdegree\n \n \nFunction\n.\n\n\noutdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.setheight!\n \n \nMethod\n.\n\n\nsetheight!(tree::AbstractTree, nodename, height)\n\n\n\n\n\nSet the height of the node.\n\n\nsource\n\n\n#\n\n\nPhylo.setleafinfo!\n \n \nMethod\n.\n\n\nsetleafinfo!(::AbstractTree, label, value)\n\n\n\n\n\nSet the leaf info for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setnoderecord!\n \n \nMethod\n.\n\n\nsetnoderecord(::AbstractTree, label, value)\n\n\n\n\n\nSet the node record for a node of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setrootheight!\n \n \nMethod\n.\n\n\nsetrootheight!(tree::AbstractTree, height)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.src\n \n \nFunction\n.\n\n\nsrc(branch::AbstractBranch)\nsrc(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the source node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.validate\n \n \nMethod\n.\n\n\nvalidate(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n\n\nPhylo\n\n\nPhylo.API\n\n\nPhylo.BinaryNode\n\n\nPhylo.BinaryTree\n\n\nPhylo.Branch\n\n\nPhylo.NamedPolytomousTree\n\n\nPhylo.NamedTree\n\n\nPhylo.Node\n\n\nPhylo.Nonultrametric\n\n\nPhylo.PolytomousTree\n\n\nPhylo.Ultrametric\n\n\nPhylo.API._addbranch!\n\n\nPhylo.API._addnode!\n\n\nPhylo.API._addnodes!\n\n\nPhylo.API._addoutbound!\n\n\nPhylo.API._branch!\n\n\nPhylo.API._branchtype\n\n\nPhylo.API._deletebranch!\n\n\nPhylo.API._deletenode!\n\n\nPhylo.API._deleteoutbound!\n\n\nPhylo.API._dst\n\n\nPhylo.API._getbranch\n\n\nPhylo.API._getbranches\n\n\nPhylo.API._getbranchnames\n\n\nPhylo.API._getheight\n\n\nPhylo.API._getinbound\n\n\nPhylo.API._getlength\n\n\nPhylo.API._getnode\n\n\nPhylo.API._getnodenames\n\n\nPhylo.API._getnodes\n\n\nPhylo.API._getoutbounds\n\n\nPhylo.API._getrootheight\n\n\nPhylo.API._hasbranch\n\n\nPhylo.API._hasheight\n\n\nPhylo.API._hasinbound\n\n\nPhylo.API._hasinboundspace\n\n\nPhylo.API._hasnode\n\n\nPhylo.API._hasoutboundspace\n\n\nPhylo.API._hasrootheight\n\n\nPhylo.API._indegree\n\n\nPhylo.API._isinternal\n\n\nPhylo.API._isleaf\n\n\nPhylo.API._isroot\n\n\nPhylo.API._isunattached\n\n\nPhylo.API._newbranchlabel\n\n\nPhylo.API._newnodelabel\n\n\nPhylo.API._nodetype\n\n\nPhylo.API._outdegree\n\n\nPhylo.API._setdst!\n\n\nPhylo.API._setheight!\n\n\nPhylo.API._setinbound!\n\n\nPhylo.API._setrootheight!\n\n\nPhylo.API._setsrc!\n\n\nPhylo.API._src\n\n\nPhylo.API._validate\n\n\nPhylo.addbranch!\n\n\nPhylo.addnode!\n\n\nPhylo.addnodes!\n\n\nPhylo.branch!\n\n\nPhylo.branchfilter\n\n\nPhylo.branchhistory\n\n\nPhylo.branchiter\n\n\nPhylo.branchnamefilter\n\n\nPhylo.branchnameiter\n\n\nPhylo.branchnametype\n\n\nPhylo.branchroute\n\n\nPhylo.branchtype\n\n\nPhylo.changedst!\n\n\nPhylo.changesrc!\n\n\nPhylo.clearrootheight!\n\n\nPhylo.deletebranch!\n\n\nPhylo.deletenode!\n\n\nPhylo.distance\n\n\nPhylo.distances\n\n\nPhylo.droptips!\n\n\nPhylo.dst\n\n\nPhylo.getancestors\n\n\nPhylo.getbranch\n\n\nPhylo.getbranchnames\n\n\nPhylo.getchildren\n\n\nPhylo.getdescendants\n\n\nPhylo.getheight\n\n\nPhylo.getinbound\n\n\nPhylo.getleafinfo\n\n\nPhylo.getleafnames\n\n\nPhylo.getlength\n\n\nPhylo.getnode\n\n\nPhylo.getnodenames\n\n\nPhylo.getnoderecord\n\n\nPhylo.getoutbounds\n\n\nPhylo.getparent\n\n\nPhylo.getrootheight\n\n\nPhylo.hasbranch\n\n\nPhylo.hasheight\n\n\nPhylo.hasinbound\n\n\nPhylo.hasinboundspace\n\n\nPhylo.hasnode\n\n\nPhylo.hasoutboundspace\n\n\nPhylo.hasrootheight\n\n\nPhylo.heightstoroot\n\n\nPhylo.heighttoroot\n\n\nPhylo.indegree\n\n\nPhylo.isinternal\n\n\nPhylo.isleaf\n\n\nPhylo.isroot\n\n\nPhylo.isunattached\n\n\nPhylo.keeptips!\n\n\nPhylo.nodefilter\n\n\nPhylo.nodehistory\n\n\nPhylo.nodeiter\n\n\nPhylo.nodenamefilter\n\n\nPhylo.nodenameiter\n\n\nPhylo.nodenametype\n\n\nPhylo.noderoute\n\n\nPhylo.nodetype\n\n\nPhylo.outdegree\n\n\nPhylo.setheight!\n\n\nPhylo.setleafinfo!\n\n\nPhylo.setnoderecord!\n\n\nPhylo.setrootheight!\n\n\nPhylo.src\n\n\nPhylo.validate", 
            "title": "Introduction"
        }, 
        {
            "location": "/#phylo", 
            "text": "Package for creating and manipulating phylogenies  Phylo  is a  Julia  package that provides  functionality for generating phylogenetic trees to feed into our   Diversity  package to calculate phylogenetic  diversity (currently on master, accessible via  Pkg.checkout() ,  but not released). Both are currently under development, so please   raise an issue  if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from  Distributions . For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:  julia   using   Phylo  julia   nu   =   Nonultrametric ( 5 );  julia   tree   =   rand ( nu )  NamedTree   phylogenetic   tree   with   9   nodes   and   8   branches  Leaf   names :  String [ tip 1 ,   tip 2 ,   tip 3 ,   tip 4 ,   tip 5 ]   The code also provides iterators, and filtered iterators over the branches, nodes, branchnames and nodenames of a tree:  julia   collect ( nodeiter ( tree ))  9 - element   Array { Phylo . BinaryNode { Int64 }, 1 } : \n  [ branch   4 ] -- [ leaf   node ] \n  [ branch   5 ] -- [ leaf   node ] \n  [ branch   2 ] -- [ leaf   node ] \n  [ branch   1 ] -- [ leaf   node ] \n  [ branch   8 ] -- [ leaf   node ] \n  [ branch   3 ] -- [ internal   node ] -- [ branches   1   and   2 ] \n  [ branch   6 ] -- [ internal   node ] -- [ branches   3   and   4 ] \n  [ branch   7 ] -- [ internal   node ] -- [ branches   5   and   6 ] \n  [ root   node ] -- [ branches   7   and   8 ]  julia   collect ( nodenamefilter ( isroot ,   tree ))  1 - element   Array { String , 1 } : \n  Node 4   The current main purpose of this package is to provide a framework for phylogenetics to use in our  Diversity  package, and they will both be adapted as appropriate until both are functioning as required (though they are currently working together reasonably successfully).  However, it can also read newick trees:  julia   using   Phylo  julia   simpletree   =   parsenewick ( ((,Tip:1.0)Internal,)Root; )  NamedTree   phylogenetic   tree   with   5   nodes   and   4   branches  Leaf   names :  String [ Node 2 ,   Tip ,   Node 1 ]  julia   getbranches ( simpletree )  Dict { Int64 , Phylo . Branch { String }}   with   4   entries : \n   4   =   [ node   Root ] -- [ NaN   length   branch ] -- [ node   Node 2 ] \n   2   =   [ node   Internal ] -- [ 1.0   length   branch ] -- [ node   Tip ] \n   3   =   [ node   Root ] -- [ NaN   length   branch ] -- [ node   Internal ] \n   1   =   [ node   Internal ] -- [ NaN   length   branch ] -- [ node   Node 1 ]  julia   open ( parsenewick ,   tree   =   open ( parsenewick ,   Pkg . dir ( Phylo ,   test ,   h1n1.trees )))  NamedTree   phylogenetic   tree   with   1013   nodes   and   1012   branches  Leaf   names :  String [ 407 ,   153 ,   1 ,   54 ,   101 ,   371 ,   41 ,   464 ,   65 ,   475    \u2026    336 ,   145 ,   36 ,   95 ,   414 ,   138 ,   294 ,   353 ,   232 ,   306 ]   And while we wait for me (or kind  contributors !) to fill out the other extensive functionality that many phylogenetics packages have in other languages, the other important feature that it offers is a fully(?)-functional interface to R, allowing any existing R library functions to be carried out on julia trees, and trees to be read from disk and written using R helper functions. Naturally the medium-term plan is to fill in as many of these gaps as possible in Julia, and as a result this R interface is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, if you want to use the R interface you need to do it manually, as below:  julia   using   RCall  julia   include ( joinpath ( Pkg . dir ( Phylo ),   src ,   rcall.jl ));  R   library ( ape )   You can then translate back and forth using  NamedTree  contructors on R  phylo  objects, and  RObject  constructors on julia  NamedTree  types to keep them in Julia or  @rput  to move the object into R:  julia   rt   =   rcall ( : rtree ,   10 )  RCall . RObject { RCall . VecSxp }  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  julia   jt   =   NamedTree ( rt )  NamedTree   phylogenetic   tree   with   19   nodes   and   18   branches  Leaf   names :  String [ t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   t3 ,   t4 ,   t7 ,   t9 ]  julia   @rput   rt ;  julia   @rput   jt ;   # Automatically translates jt back to R  R   jt  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  R   all . equal ( rt ,   jt )   # check no damage in translations  [ 1 ]   TRUE    Phylo   #  Phylo     Module .  Phylo package  The  Phylo  package provides a standard abstract interface to phylogenetic trees, by defining  AbstractNode ,  AbstractBranch  and  AbstractTree  supertypes, and methods to interface to them. It also provides (through the  Phylo.API  submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.  source  #  Phylo.BinaryNode     Type .  BinaryNode{T}(AbstractVector{T}, AbstractVector{T})  : AbstractNode  A node of strict binary phylogenetic tree  source  #  Phylo.BinaryTree     Type .  BinaryTree  Binary phylogenetic tree object with known leaves and per node data  source  #  Phylo.Branch     Type .  Branch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree  source  #  Phylo.NamedPolytomousTree     Type .  NamedPolytomousTree  Binary phylogenetic tree object with known leaves  source  #  Phylo.NamedTree     Type .  NamedBinaryTree  Binary phylogenetic tree object with known leaves  source  #  Phylo.Node     Type .  Node{T}(AbstractVector{T}, AbstractVector{T})  : AbstractNode  A node of potentially polytomous phylogenetic tree  source  #  Phylo.Nonultrametric     Type .  Nonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(n::Int,\n                                  rng::RNG = Exponential())\nNonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(tiplabels::Vector{String},\n                                  rng::RNG = Exponential())  The sampler for non-ultrametric phylogenetic trees of size  n  or with tip labels  tiplabels . Generate random trees by calling rand(). Currently only works for  NamedTree s.  source  #  Phylo.PolytomousTree     Type .  PolytomousTree  Phylogenetic tree object with polytomous branching, and known leaves and per node data  source  #  Phylo.Ultrametric     Type .  Ultrametric{T  : AbstractTree,\n            RNG  : Sampleable}(n::Int,\n                               rng::RNG = Exponential())\nUltrametric{T  : AbstractTree,\n            RNG  : Sampleable}(tiplabels::Vector{String},\n                               rng::RNG = Exponential())  The sampler for ultrametric phylogenetic trees of size  n  or with tip labels  tiplabels . Generate random trees by calling rand(). Currently only works for  NamedTree s.  source  #  Phylo.addbranch!     Function .  addbranch !( tree :: AbstractTree ,   source ,   destination [ ,   length ::Float64 ] ; \n            branchname   =   _newbranchlabel ( tree ))   Add a branch from  source  to  destination  on  tree .  source  #  Phylo.addnode!     Function .  addnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)  source  #  Phylo.addnodes!     Function .  addnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)  source  #  Phylo.branch!     Function .  branch !( tree :: AbstractTree ,   source [ ,   length ] )  branch !( tree :: AbstractTree ,   source [ ,   length ] ;   destination )  branch !( tree :: AbstractTree ,   source [ ,   length ] ;   destination ,   branchname )   Branch from a source node  source  and create a destination node  destination .  source  #  Phylo.branchfilter     Method .  branchfilter(filterfn::Function, tree::AbstractTree)  Returns an iterator over the branches of any tree, where the  AbstractBranch  is filtered by the function  filterfn .  source  #  Phylo.branchhistory     Method .  branchhistory(tree::AbstractTree, node)  Find the branch route between a node on a tree and its root  source  #  Phylo.branchiter     Method .  branchiter(tree::AbstractTree)  Returns an iterator over the branches of any tree.  source  #  Phylo.branchnamefilter     Method .  branchnamefilter(filterfn::Function, tree::AbstractTree)  Returns an iterator over the names of the branches of any tree, where the  AbstractBranch  is filtered by the function  filterfn .  source  #  Phylo.branchnameiter     Method .  branchnameiter(tree::AbstractTree)  Returns an iterator over the names of branches of any tree.  source  #  Phylo.branchnametype     Method .  branchnametype(::AbstractTree)  Returns type of branch names.  source  #  Phylo.branchroute     Method .  branchroute(tree::AbstractTree, node1, node2)  Find the branch route between two nodes on a tree  source  #  Phylo.branchtype     Method .  branchtype(tree::AbstractTree)  Returns type of branches in a tree.  source  #  Phylo.changedst!     Method .  changedst!(tree::AbstractTree, branchname, destination)  Change the destination node for this node.  source  #  Phylo.changesrc!     Method .  changesrc!(tree::AbstractTree, branchname, source)  Change the source node for this branch.  source  #  Phylo.clearrootheight!     Method .  clearrootheight(::AbstractTree)  Clears the tree's root height record.  source  #  Phylo.deletebranch!     Method .  deletebranch!(tree::AbstractTree, branchname)  Delete the branch  branchname  from  tree .  source  #  Phylo.deletenode!     Method .  deletenode!(tree::AbstractTree, nodename)  source  #  Phylo.distance     Method .  distance(tree::AbstractTree, node1, node2)  Distance between two nodes on a tree  source  #  Phylo.distances     Method .  distances(tree::AbstractTree)  Pairwise distances between all leaf nodes on a tree  source  #  Phylo.droptips!     Method .  droptips!(t::T, tips::Vector{NL}) where {NL, BL, T  : AbstractTree{NL, BL}}  Function to drop tips from a phylogenetic tree  t , which are found in the vector of tip names,  tips .  source  #  Phylo.dst     Function .  dst(branch::AbstractBranch)\ndst(tree::AbstractTree, branchname)  Return the destination node for this branch.  source  #  Phylo.getancestors     Method .  getancestors(tree::AbstractTree, nodename)  Return the name of all of the nodes that are ancestral to this node.  source  #  Phylo.getbranch     Method .  getbranch(tree::AbstractTree, branchname)  source  #  Phylo.getbranchnames     Method .  getbranchnames(tree::AbstractTree)  source  #  Phylo.getchildren     Method .  getchildren(tree::AbstractTree, nodename)  Return the name(s) of the child node(s) for this node.  source  #  Phylo.getdescendants     Method .  getdescendants(tree::AbstractTree, nodename)  Return the names of all of the nodes that descend from this node.  source  #  Phylo.getheight     Method .  getheight(tree::AbstractTree, nodename)  Return the height of the node.  source  #  Phylo.getinbound     Function .  getinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)  return the name of the inbound branch to this node.  source  #  Phylo.getleafinfo     Method .  getleafinfo(::AbstractTree, label)  retrieve the leaf info for a leaf of the tree.  source  #  Phylo.getleafnames     Method .  getleafnames(::AbstractTree)  Retrieve the leaf names from the tree.  source  #  Phylo.getlength     Function .  getlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)  Return the length of this branch.  source  #  Phylo.getnode     Method .  getnode(tree::AbstractTree, nodename)  source  #  Phylo.getnodenames     Method .  getnodenames(tree::AbstractTree)  source  #  Phylo.getnoderecord     Method .  getnoderecord(::AbstractTree, label)  retrieve the node record for a leaf of the tree.  source  #  Phylo.getoutbounds     Function .  getoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)  Return the names of the outbound branches from this node.  source  #  Phylo.getparent     Method .  getparent(tree::AbstractTree, nodename)  Return the name of the parent node for this node.  source  #  Phylo.getrootheight     Method .  getrootheight(tree::AbstractTree)  source  #  Phylo.hasbranch     Method .  hasbranch(tree::AbstractTree, branchname)  source  #  Phylo.hasheight     Function .  hasheight(tree::AbstractTree, nodename)  Does the node have a height defined?  source  #  Phylo.hasinbound     Function .  hasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)  Does the node have an inbound connection?  source  #  Phylo.hasinboundspace     Function .  hasinboundspace(node::AbstractNode)\nhasinboundspace(tree::AbstractTree, nodename)  Does the node have space for an inbound connection?  source  #  Phylo.hasnode     Method .  hasnode(tree::AbstractTree, nodename)  source  #  Phylo.hasoutboundspace     Function .  hasoutboundspace(node::AbstractNode)\nhasoutboundspace(tree::AbstractTree, nodename)  Does the node have space for an[other] outbound connection?  source  #  Phylo.hasrootheight     Method .  hasrootheight(tree::AbstractTree)  source  #  Phylo.heightstoroot     Method .  heights(tree::AbstractTree)  Height of all of the leaves of the tree above the root   source  #  Phylo.heighttoroot     Method .  height(tree::AbstractTree, node)  Height of a node of the tree above the root   source  #  Phylo.indegree     Function .  indegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)  source  #  Phylo.isinternal     Function .  isinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)  source  #  Phylo.isleaf     Function .  isleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)  source  #  Phylo.isroot     Function .  isroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)  source  #  Phylo.isunattached     Function .  isunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)  source  #  Phylo.keeptips!     Method .  keeptips!(t::T, tips::Vector{NL}) where {NL, BL, T  : AbstractTree{NL, BL}}  Function to keep only the tips in a phylogenetic tree,  t , that are found in the vector of tip names,  tip .  source  #  Phylo.nodefilter     Method .  nodefilter(filterfn::Function, tree::AbstractTree)  Returns an iterator over the nodes of any tree, where the  AbstractNode  is filtered by the function  filterfn .  source  #  Phylo.nodehistory     Method .  nodehistory(tree::AbstractTree, node)  Find the node route between a node on a tree and its root  source  #  Phylo.nodeiter     Method .  nodeiter(tree::AbstractTree)  Returns an iterator over the nodes of any tree.  source  #  Phylo.nodenamefilter     Method .  nodenamefilter(filterfn::Function, tree::AbstractTree)  Returns an iterator over the nodenames of any tree, where the  AbstractNode  itself is filtered by the function  filterfn .  source  #  Phylo.nodenameiter     Method .  nodenameiter(tree::AbstractTree)  Returns an iterator over the names of the nodes of any tree.  source  #  Phylo.nodenametype     Method .  nodenametype(::AbstractTree)  Returns type of node names.  source  #  Phylo.noderoute     Method .  noderoute(tree::AbstractTree, node1, node2)  Find the node route between two nodes on a tree  source  #  Phylo.nodetype     Method .  nodetype(tree::AbstractTree)  Returns type of nodes in a tree.  source  #  Phylo.outdegree     Function .  outdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)  source  #  Phylo.setheight!     Method .  setheight!(tree::AbstractTree, nodename, height)  Set the height of the node.  source  #  Phylo.setleafinfo!     Method .  setleafinfo!(::AbstractTree, label, value)  Set the leaf info for a leaf of the tree.  source  #  Phylo.setnoderecord!     Method .  setnoderecord(::AbstractTree, label, value)  Set the node record for a node of the tree.  source  #  Phylo.setrootheight!     Method .  setrootheight!(tree::AbstractTree, height)  source  #  Phylo.src     Function .  src(branch::AbstractBranch)\nsrc(tree::AbstractTree, branchname)  Return the source node for this branch.  source  #  Phylo.validate     Method .  validate(tree::AbstractTree)  source   Phylo  Phylo.API  Phylo.BinaryNode  Phylo.BinaryTree  Phylo.Branch  Phylo.NamedPolytomousTree  Phylo.NamedTree  Phylo.Node  Phylo.Nonultrametric  Phylo.PolytomousTree  Phylo.Ultrametric  Phylo.API._addbranch!  Phylo.API._addnode!  Phylo.API._addnodes!  Phylo.API._addoutbound!  Phylo.API._branch!  Phylo.API._branchtype  Phylo.API._deletebranch!  Phylo.API._deletenode!  Phylo.API._deleteoutbound!  Phylo.API._dst  Phylo.API._getbranch  Phylo.API._getbranches  Phylo.API._getbranchnames  Phylo.API._getheight  Phylo.API._getinbound  Phylo.API._getlength  Phylo.API._getnode  Phylo.API._getnodenames  Phylo.API._getnodes  Phylo.API._getoutbounds  Phylo.API._getrootheight  Phylo.API._hasbranch  Phylo.API._hasheight  Phylo.API._hasinbound  Phylo.API._hasinboundspace  Phylo.API._hasnode  Phylo.API._hasoutboundspace  Phylo.API._hasrootheight  Phylo.API._indegree  Phylo.API._isinternal  Phylo.API._isleaf  Phylo.API._isroot  Phylo.API._isunattached  Phylo.API._newbranchlabel  Phylo.API._newnodelabel  Phylo.API._nodetype  Phylo.API._outdegree  Phylo.API._setdst!  Phylo.API._setheight!  Phylo.API._setinbound!  Phylo.API._setrootheight!  Phylo.API._setsrc!  Phylo.API._src  Phylo.API._validate  Phylo.addbranch!  Phylo.addnode!  Phylo.addnodes!  Phylo.branch!  Phylo.branchfilter  Phylo.branchhistory  Phylo.branchiter  Phylo.branchnamefilter  Phylo.branchnameiter  Phylo.branchnametype  Phylo.branchroute  Phylo.branchtype  Phylo.changedst!  Phylo.changesrc!  Phylo.clearrootheight!  Phylo.deletebranch!  Phylo.deletenode!  Phylo.distance  Phylo.distances  Phylo.droptips!  Phylo.dst  Phylo.getancestors  Phylo.getbranch  Phylo.getbranchnames  Phylo.getchildren  Phylo.getdescendants  Phylo.getheight  Phylo.getinbound  Phylo.getleafinfo  Phylo.getleafnames  Phylo.getlength  Phylo.getnode  Phylo.getnodenames  Phylo.getnoderecord  Phylo.getoutbounds  Phylo.getparent  Phylo.getrootheight  Phylo.hasbranch  Phylo.hasheight  Phylo.hasinbound  Phylo.hasinboundspace  Phylo.hasnode  Phylo.hasoutboundspace  Phylo.hasrootheight  Phylo.heightstoroot  Phylo.heighttoroot  Phylo.indegree  Phylo.isinternal  Phylo.isleaf  Phylo.isroot  Phylo.isunattached  Phylo.keeptips!  Phylo.nodefilter  Phylo.nodehistory  Phylo.nodeiter  Phylo.nodenamefilter  Phylo.nodenameiter  Phylo.nodenametype  Phylo.noderoute  Phylo.nodetype  Phylo.outdegree  Phylo.setheight!  Phylo.setleafinfo!  Phylo.setnoderecord!  Phylo.setrootheight!  Phylo.src  Phylo.validate", 
            "title": "Phylo"
        }, 
        {
            "location": "/api/", 
            "text": "The \nPhylo.API\n submodule provides the API that must be extended for new \nAbstractTree\n, \nAbstractNode\n and \nAbstractBranch\n subtypes.\n\n\n\n\nUsage\n\n\nProviding additional code to extend the functionality of the system is simple:\n\n\nusing\n \nPhylo\n\n\nimportall\n \nPhylo\n.\nAPI\n\n\n\ntype\n \nSimplestTree\n \n:\n \nAbstractTree\n{\nInt\n,\n \nInt\n}\n\n    \nnodes\n::\nOrderedDict\n{\nInt\n,\n \nBinaryNode\n{\nInt\n}}\n\n    \nbranches\n::\nDict\n{\nInt\n,\n \nBranch\n{\nInt\n}}\n\n\nend\n\n\n\nfunction\n \n_addnode\n!\n(\ntree\n::\nSimplestTree\n,\n \nnum\n)\n\n    \n_setnode\n!\n(\ntree\n,\n \nnum\n,\n \nBinaryNode\n{\nInt\n}())\n\n    \nreturn\n \nnum\n\n\nend\n\n\n\n\n\n\ncreates a new \nSimplestTree\n type (a subtype of \nAbstractTree\n) and extends \nPhylo.API._addnode!()\n (and therefore the directly accessible \naddnode!()\n interface) to handle the \nSimplestTree\n subtype of \nAbstractTree\n. See docs here to see which \nPhylo.API\n functions have to be extended for any new subtype, and which have default implementations.\n\n\n\n\nPhylo\n\n\n\n\n#\n\n\nPhylo.API\n \n \nModule\n.\n\n\nPhylo.API submodule\n\n\n\n\n\nThe \nPhylo.API\n submodule should be \nimport[all]\ned if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addbranch!\n \n \nFunction\n.\n\n\n_addbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n,\n \ndestination\n;\n\n            \nlength\n::\nFloat64\n \n=\n \nNaN\n,\n\n            \nbranchname\n \n=\n \n_newbranchlabel\n(\ntree\n))\n\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addnode!\n \n \nFunction\n.\n\n\n_addnode!(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addnodes!\n \n \nFunction\n.\n\n\n_addnodes!(tree::AbstractTree, nodenames::AbstractVector)\n_addnodes!(tree:AbstractTree, count::Integer)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._addoutbound!\n \n \nFunction\n.\n\n\n_addinbound!(node::AbstractNode, outbound)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._branch!\n \n \nMethod\n.\n\n\n_branch!(tree::AbstractTree, source, length::Float64, destination, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._branchtype\n \n \nFunction\n.\n\n\n_branchtype(::AbstractTree)\n\n\n\n\n\nReturns type of branches in a tree.\n\n\nsource\n\n\n#\n\n\nPhylo.API._deletebranch!\n \n \nFunction\n.\n\n\n_deletebranch!(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._deletenode!\n \n \nFunction\n.\n\n\n_deletenode!(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._deleteoutbound!\n \n \nFunction\n.\n\n\n_deleteoutbound!(node::AbstractNode, outbound)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._dst\n \n \nFunction\n.\n\n\n_dst\n\n\n\n\n\nReturn destination node for a branch. Must be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranch\n \n \nFunction\n.\n\n\n_getbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranches\n \n \nFunction\n.\n\n\n_getbranches(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranchnames\n \n \nFunction\n.\n\n\n_getbranchnames(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getheight\n \n \nMethod\n.\n\n\n_getheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._getinbound\n \n \nFunction\n.\n\n\n_getinbound(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getlength\n \n \nFunction\n.\n\n\n_getlength\n\n\n\n\n\nReturn length of a branch. May be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnode\n \n \nFunction\n.\n\n\n_getnode(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnodenames\n \n \nFunction\n.\n\n\n_getnodenames(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnodes\n \n \nFunction\n.\n\n\n_getnodes(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getoutbounds\n \n \nFunction\n.\n\n\n_getoutbounds(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getrootheight\n \n \nMethod\n.\n\n\n_getrootheight(::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasbranch\n \n \nFunction\n.\n\n\n_hasbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasheight\n \n \nMethod\n.\n\n\n_hasheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasinbound\n \n \nFunction\n.\n\n\n_hasinbound(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasinboundspace\n \n \nMethod\n.\n\n\n_hasinboundspace(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasnode\n \n \nFunction\n.\n\n\n_hasnode(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasoutboundspace\n \n \nFunction\n.\n\n\n_hasoutboundspace(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasrootheight\n \n \nMethod\n.\n\n\n_hasrootheight(::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._indegree\n \n \nMethod\n.\n\n\n_indegree(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isinternal\n \n \nMethod\n.\n\n\n_isinternal(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isleaf\n \n \nMethod\n.\n\n\n_isleaf(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isroot\n \n \nMethod\n.\n\n\n_isroot(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isunattached\n \n \nMethod\n.\n\n\n_isunattached(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._newbranchlabel\n \n \nFunction\n.\n\n\n_newbranchlabel(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._newnodelabel\n \n \nFunction\n.\n\n\n_newnodelabel(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._nodetype\n \n \nFunction\n.\n\n\n_nodetype(::AbstractTree)\n\n\n\n\n\nReturns type of nodes in a tree.\n\n\nsource\n\n\n#\n\n\nPhylo.API._outdegree\n \n \nFunction\n.\n\n\n_outdegree(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._setdst!\n \n \nFunction\n.\n\n\n_setdst!\n\n\n\n\n\nSet destination node for a graph. Must be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._setheight!\n \n \nMethod\n.\n\n\n_setheight!(::AbstractTree, nodename, value)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._setinbound!\n \n \nFunction\n.\n\n\n_setinbound!(node::AbstractNode, inbound)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._setrootheight!\n \n \nMethod\n.\n\n\n_setrootheight!(::AbstractTree, value)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._setsrc!\n \n \nFunction\n.\n\n\n_setsrc!\n\n\n\n\n\nSet source node for a branch. Must be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._src\n \n \nFunction\n.\n\n\n_src\n\n\n\n\n\nReturn source node for a branch. Must be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._validate\n \n \nMethod\n.\n\n\n_validate(::AbstractTree)\n\n\n\n\n\nsource\n\n\n\n\nPhylo\n\n\nPhylo.API\n\n\nPhylo.BinaryNode\n\n\nPhylo.BinaryTree\n\n\nPhylo.Branch\n\n\nPhylo.NamedPolytomousTree\n\n\nPhylo.NamedTree\n\n\nPhylo.Node\n\n\nPhylo.Nonultrametric\n\n\nPhylo.PolytomousTree\n\n\nPhylo.Ultrametric\n\n\nPhylo.API._addbranch!\n\n\nPhylo.API._addnode!\n\n\nPhylo.API._addnodes!\n\n\nPhylo.API._addoutbound!\n\n\nPhylo.API._branch!\n\n\nPhylo.API._branchtype\n\n\nPhylo.API._deletebranch!\n\n\nPhylo.API._deletenode!\n\n\nPhylo.API._deleteoutbound!\n\n\nPhylo.API._dst\n\n\nPhylo.API._getbranch\n\n\nPhylo.API._getbranches\n\n\nPhylo.API._getbranchnames\n\n\nPhylo.API._getheight\n\n\nPhylo.API._getinbound\n\n\nPhylo.API._getlength\n\n\nPhylo.API._getnode\n\n\nPhylo.API._getnodenames\n\n\nPhylo.API._getnodes\n\n\nPhylo.API._getoutbounds\n\n\nPhylo.API._getrootheight\n\n\nPhylo.API._hasbranch\n\n\nPhylo.API._hasheight\n\n\nPhylo.API._hasinbound\n\n\nPhylo.API._hasinboundspace\n\n\nPhylo.API._hasnode\n\n\nPhylo.API._hasoutboundspace\n\n\nPhylo.API._hasrootheight\n\n\nPhylo.API._indegree\n\n\nPhylo.API._isinternal\n\n\nPhylo.API._isleaf\n\n\nPhylo.API._isroot\n\n\nPhylo.API._isunattached\n\n\nPhylo.API._newbranchlabel\n\n\nPhylo.API._newnodelabel\n\n\nPhylo.API._nodetype\n\n\nPhylo.API._outdegree\n\n\nPhylo.API._setdst!\n\n\nPhylo.API._setheight!\n\n\nPhylo.API._setinbound!\n\n\nPhylo.API._setrootheight!\n\n\nPhylo.API._setsrc!\n\n\nPhylo.API._src\n\n\nPhylo.API._validate\n\n\nPhylo.addbranch!\n\n\nPhylo.addnode!\n\n\nPhylo.addnodes!\n\n\nPhylo.branch!\n\n\nPhylo.branchfilter\n\n\nPhylo.branchhistory\n\n\nPhylo.branchiter\n\n\nPhylo.branchnamefilter\n\n\nPhylo.branchnameiter\n\n\nPhylo.branchnametype\n\n\nPhylo.branchroute\n\n\nPhylo.branchtype\n\n\nPhylo.changedst!\n\n\nPhylo.changesrc!\n\n\nPhylo.clearrootheight!\n\n\nPhylo.deletebranch!\n\n\nPhylo.deletenode!\n\n\nPhylo.distance\n\n\nPhylo.distances\n\n\nPhylo.droptips!\n\n\nPhylo.dst\n\n\nPhylo.getancestors\n\n\nPhylo.getbranch\n\n\nPhylo.getbranchnames\n\n\nPhylo.getchildren\n\n\nPhylo.getdescendants\n\n\nPhylo.getheight\n\n\nPhylo.getinbound\n\n\nPhylo.getleafinfo\n\n\nPhylo.getleafnames\n\n\nPhylo.getlength\n\n\nPhylo.getnode\n\n\nPhylo.getnodenames\n\n\nPhylo.getnoderecord\n\n\nPhylo.getoutbounds\n\n\nPhylo.getparent\n\n\nPhylo.getrootheight\n\n\nPhylo.hasbranch\n\n\nPhylo.hasheight\n\n\nPhylo.hasinbound\n\n\nPhylo.hasinboundspace\n\n\nPhylo.hasnode\n\n\nPhylo.hasoutboundspace\n\n\nPhylo.hasrootheight\n\n\nPhylo.heightstoroot\n\n\nPhylo.heighttoroot\n\n\nPhylo.indegree\n\n\nPhylo.isinternal\n\n\nPhylo.isleaf\n\n\nPhylo.isroot\n\n\nPhylo.isunattached\n\n\nPhylo.keeptips!\n\n\nPhylo.nodefilter\n\n\nPhylo.nodehistory\n\n\nPhylo.nodeiter\n\n\nPhylo.nodenamefilter\n\n\nPhylo.nodenameiter\n\n\nPhylo.nodenametype\n\n\nPhylo.noderoute\n\n\nPhylo.nodetype\n\n\nPhylo.outdegree\n\n\nPhylo.setheight!\n\n\nPhylo.setleafinfo!\n\n\nPhylo.setnoderecord!\n\n\nPhylo.setrootheight!\n\n\nPhylo.src\n\n\nPhylo.validate", 
            "title": "API"
        }, 
        {
            "location": "/api/#usage", 
            "text": "Providing additional code to extend the functionality of the system is simple:  using   Phylo  importall   Phylo . API  type   SimplestTree   :   AbstractTree { Int ,   Int } \n     nodes :: OrderedDict { Int ,   BinaryNode { Int }} \n     branches :: Dict { Int ,   Branch { Int }}  end  function   _addnode ! ( tree :: SimplestTree ,   num ) \n     _setnode ! ( tree ,   num ,   BinaryNode { Int }()) \n     return   num  end   creates a new  SimplestTree  type (a subtype of  AbstractTree ) and extends  Phylo.API._addnode!()  (and therefore the directly accessible  addnode!()  interface) to handle the  SimplestTree  subtype of  AbstractTree . See docs here to see which  Phylo.API  functions have to be extended for any new subtype, and which have default implementations.   Phylo   #  Phylo.API     Module .  Phylo.API submodule  The  Phylo.API  submodule should be  import[all] ed if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.  source  #  Phylo.API._addbranch!     Function .  _addbranch !( tree :: AbstractTree ,   source ,   destination ; \n             length :: Float64   =   NaN , \n             branchname   =   _newbranchlabel ( tree ))   Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._addnode!     Function .  _addnode!(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._addnodes!     Function .  _addnodes!(tree::AbstractTree, nodenames::AbstractVector)\n_addnodes!(tree:AbstractTree, count::Integer)  source  #  Phylo.API._addoutbound!     Function .  _addinbound!(node::AbstractNode, outbound)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._branch!     Method .  _branch!(tree::AbstractTree, source, length::Float64, destination, branchname)  source  #  Phylo.API._branchtype     Function .  _branchtype(::AbstractTree)  Returns type of branches in a tree.  source  #  Phylo.API._deletebranch!     Function .  _deletebranch!(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._deletenode!     Function .  _deletenode!(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._deleteoutbound!     Function .  _deleteoutbound!(node::AbstractNode, outbound)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._dst     Function .  _dst  Return destination node for a branch. Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._getbranch     Function .  _getbranch(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getbranches     Function .  _getbranches(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getbranchnames     Function .  _getbranchnames(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getheight     Method .  _getheight(tree::AbstractTree, nodename)  source  #  Phylo.API._getinbound     Function .  _getinbound(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._getlength     Function .  _getlength  Return length of a branch. May be implemented for any AbstractBranch subtype.  source  #  Phylo.API._getnode     Function .  _getnode(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getnodenames     Function .  _getnodenames(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getnodes     Function .  _getnodes(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getoutbounds     Function .  _getoutbounds(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._getrootheight     Method .  _getrootheight(::AbstractTree)  source  #  Phylo.API._hasbranch     Function .  _hasbranch(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._hasheight     Method .  _hasheight(tree::AbstractTree, nodename)  source  #  Phylo.API._hasinbound     Function .  _hasinbound(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._hasinboundspace     Method .  _hasinboundspace(node::AbstractNode)  source  #  Phylo.API._hasnode     Function .  _hasnode(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._hasoutboundspace     Function .  _hasoutboundspace(node::AbstractNode)  source  #  Phylo.API._hasrootheight     Method .  _hasrootheight(::AbstractTree)  source  #  Phylo.API._indegree     Method .  _indegree(node::AbstractNode)  source  #  Phylo.API._isinternal     Method .  _isinternal(node::AbstractNode)  source  #  Phylo.API._isleaf     Method .  _isleaf(node::AbstractNode)  source  #  Phylo.API._isroot     Method .  _isroot(node::AbstractNode)  source  #  Phylo.API._isunattached     Method .  _isunattached(node::AbstractNode)  source  #  Phylo.API._newbranchlabel     Function .  _newbranchlabel(tree::AbstractTree)  source  #  Phylo.API._newnodelabel     Function .  _newnodelabel(tree::AbstractTree)  source  #  Phylo.API._nodetype     Function .  _nodetype(::AbstractTree)  Returns type of nodes in a tree.  source  #  Phylo.API._outdegree     Function .  _outdegree(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._setdst!     Function .  _setdst!  Set destination node for a graph. Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._setheight!     Method .  _setheight!(::AbstractTree, nodename, value)  source  #  Phylo.API._setinbound!     Function .  _setinbound!(node::AbstractNode, inbound)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._setrootheight!     Method .  _setrootheight!(::AbstractTree, value)  source  #  Phylo.API._setsrc!     Function .  _setsrc!  Set source node for a branch. Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._src     Function .  _src  Return source node for a branch. Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._validate     Method .  _validate(::AbstractTree)  source   Phylo  Phylo.API  Phylo.BinaryNode  Phylo.BinaryTree  Phylo.Branch  Phylo.NamedPolytomousTree  Phylo.NamedTree  Phylo.Node  Phylo.Nonultrametric  Phylo.PolytomousTree  Phylo.Ultrametric  Phylo.API._addbranch!  Phylo.API._addnode!  Phylo.API._addnodes!  Phylo.API._addoutbound!  Phylo.API._branch!  Phylo.API._branchtype  Phylo.API._deletebranch!  Phylo.API._deletenode!  Phylo.API._deleteoutbound!  Phylo.API._dst  Phylo.API._getbranch  Phylo.API._getbranches  Phylo.API._getbranchnames  Phylo.API._getheight  Phylo.API._getinbound  Phylo.API._getlength  Phylo.API._getnode  Phylo.API._getnodenames  Phylo.API._getnodes  Phylo.API._getoutbounds  Phylo.API._getrootheight  Phylo.API._hasbranch  Phylo.API._hasheight  Phylo.API._hasinbound  Phylo.API._hasinboundspace  Phylo.API._hasnode  Phylo.API._hasoutboundspace  Phylo.API._hasrootheight  Phylo.API._indegree  Phylo.API._isinternal  Phylo.API._isleaf  Phylo.API._isroot  Phylo.API._isunattached  Phylo.API._newbranchlabel  Phylo.API._newnodelabel  Phylo.API._nodetype  Phylo.API._outdegree  Phylo.API._setdst!  Phylo.API._setheight!  Phylo.API._setinbound!  Phylo.API._setrootheight!  Phylo.API._setsrc!  Phylo.API._src  Phylo.API._validate  Phylo.addbranch!  Phylo.addnode!  Phylo.addnodes!  Phylo.branch!  Phylo.branchfilter  Phylo.branchhistory  Phylo.branchiter  Phylo.branchnamefilter  Phylo.branchnameiter  Phylo.branchnametype  Phylo.branchroute  Phylo.branchtype  Phylo.changedst!  Phylo.changesrc!  Phylo.clearrootheight!  Phylo.deletebranch!  Phylo.deletenode!  Phylo.distance  Phylo.distances  Phylo.droptips!  Phylo.dst  Phylo.getancestors  Phylo.getbranch  Phylo.getbranchnames  Phylo.getchildren  Phylo.getdescendants  Phylo.getheight  Phylo.getinbound  Phylo.getleafinfo  Phylo.getleafnames  Phylo.getlength  Phylo.getnode  Phylo.getnodenames  Phylo.getnoderecord  Phylo.getoutbounds  Phylo.getparent  Phylo.getrootheight  Phylo.hasbranch  Phylo.hasheight  Phylo.hasinbound  Phylo.hasinboundspace  Phylo.hasnode  Phylo.hasoutboundspace  Phylo.hasrootheight  Phylo.heightstoroot  Phylo.heighttoroot  Phylo.indegree  Phylo.isinternal  Phylo.isleaf  Phylo.isroot  Phylo.isunattached  Phylo.keeptips!  Phylo.nodefilter  Phylo.nodehistory  Phylo.nodeiter  Phylo.nodenamefilter  Phylo.nodenameiter  Phylo.nodenametype  Phylo.noderoute  Phylo.nodetype  Phylo.outdegree  Phylo.setheight!  Phylo.setleafinfo!  Phylo.setnoderecord!  Phylo.setrootheight!  Phylo.src  Phylo.validate", 
            "title": "Usage"
        }
    ]
}