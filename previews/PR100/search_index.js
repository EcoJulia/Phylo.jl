var documenterSearchIndex = {"docs":
[{"location":"man/io/#Creating-phylogenies","page":"Creating and writing phylogenies","title":"Creating phylogenies","text":"","category":"section"},{"location":"man/io/#Reading-phylogenies-from-disk","page":"Creating and writing phylogenies","title":"Reading phylogenies from disk","text":"","category":"section"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo can read newick trees either from strings,","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"using Phylo\nsimpletree = parsenewick(\"((,Tip:1.0)Internal,)Root;\")","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"which will result in the following tree:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"getbranches(simpletree)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"or from files","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"tree = open(parsenewick, Phylo.path(\"H1N1.newick\"))","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"It can read nexus trees from files too:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"ts = open(parsenexus, Phylo.path(\"H1N1.trees\"))","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Reading multiple trees from a nexus file returns a TreeSet - index to get the individual trees","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"gettreeinfo(ts)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"ts[\"TREE1\"]","category":"page"},{"location":"man/io/#Writing-phylogenies-to-disk","page":"Creating and writing phylogenies","title":"Writing phylogenies to disk","text":"","category":"section"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo can write newick trees either to strings,","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"out = Phylo.outputtree(simpletree, Newick())","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"or to files","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo.write(\"test.newick\", simpletree)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"It can write nexus trees to files too:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo.write(\"h1.trees\", ts)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"It will use newick as the default format for OneTree trees (e.g. a RecursiveTree), and nexus for ManyTrees trees (e.g. a TreeSet). However, you can tell it to use nexus for a OneTree:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo.write(\"test.trees\", simpletree, format = Nexus())","category":"page"},{"location":"man/io/#Creating-random-phylogenies","page":"Creating and writing phylogenies","title":"Creating random phylogenies","text":"","category":"section"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"The package can be used to generate random trees using the framework from  Distributions. For instance, to construct a sampler for 5 tip non-ultrametric  trees and generate a random tree of that type","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"using Phylo\nnu = Nonultrametric(5);\ntree = rand(nu)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Or two trees","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"trees = rand(nu, [\"Tree 1\", \"Tree 2\"])","category":"page"},{"location":"man/io/#Importing-phylogenies-from-R","page":"Creating and writing phylogenies","title":"Importing phylogenies from R","text":"","category":"section"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"Phylo allows transferring trees from R's ape package directly via RCall. This allows any existing R library functions to be carried out on julia trees. Naturally the medium-term plan is to make this package feature-complete with existing functionality in R, and as a result the R interface is not built into the package, avoiding having RCall (and R) a dependency. Instead, if you want to use the R interface you need to do it manually, as below:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"julia> using RCall\n\njulia> include(Phylo.path(\"rcall.jl\", dir = \"src\"));\n\nR> library(ape)","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"You can then translate back and forth using rcopy on R phylo objects, and RObject constructors on julia NamedTree types to keep them in Julia or @rput to move the object into R:","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"julia> rt = rcall(:rtree, 10)\nRCall.RObject{RCall.VecSxp}\n\nPhylogenetic tree with 10 tips and 9 internal nodes.\n\nTip labels:\n  t10, t8, t1, t2, t6, t5, ...\n\nRooted; includes branch lengths.\n\njulia> jt = rcopy(NamedTree, rt)\nNamedTree with 10 tips, 19 nodes and 18 branches.\nLeaf names are t8, t3, t7, t9, t6, ... [4 omitted] ... and t1\n\njulia> rjt = RObject(jt); # manually translate it back to R\n\nR> if (all.equal($rjt, $rt)) \"no damage in translation\"\n[1] \"no damage in translation\"\n\njulia> @rput rt; # Or use macros to pass R object back to R\n\njulia> @rput jt; # And automatically translate jt back to R\n\nR> jt\n\nPhylogenetic tree with 10 tips and 9 internal nodes.\n\nTip labels:\n  t10, t8, t1, t2, t6, t5, ...\n\nRooted; includes branch lengths.\n\nR> if (all.equal(rt, jt)) \"no damage in translation\"\n[1] \"no damage in translation\"","category":"page"},{"location":"man/io/","page":"Creating and writing phylogenies","title":"Creating and writing phylogenies","text":"parsenewick\nparsenexus\nNonultrametric\nUltrametric\nNewick\nNexus","category":"page"},{"location":"man/io/#Phylo.parsenewick","page":"Creating and writing phylogenies","title":"Phylo.parsenewick","text":"parsenewick(io::IOBuffer, ::Type{TREE}) where TREE <: AbstractTree\n\nParse an IOBuffer containing a newick tree and convert into a phylogenetic tree of type TREE <: AbstractTree\n\n\n\n\n\nparsenewick(io::String, ::Type{TREE}) where TREE <: AbstractTree\n\nParse a String containing a newick tree and convert into a phylogenetic tree of type TREE <: AbstractTree\n\n\n\n\n\nparsenewick(io::IOStream, ::Type{TREE}) where TREE <: AbstractTree\n\nParse an IOStream containing a newick tree and convert into a phylogenetic tree of type TREE <: AbstractTree\n\n\n\n\n\nparsenewick(inp)\n\nParse some input containing a newick tree and convert into a phylogenetic tree of type RootedTree\n\n\n\n\n\n","category":"function"},{"location":"man/io/#Phylo.parsenexus","page":"Creating and writing phylogenies","title":"Phylo.parsenexus","text":"parsenexus(io::IOBuffer, ::Type{TREE}) where TREE <: AbstractTree\n\nParse an IOBuffer containing a nexus tree and convert into a phylogenetic tree of type TREE <: AbstractTree\n\n\n\n\n\nparsenexus(io::IOStream, ::Type{TREE}) where TREE <: AbstractTree\n\nParse an IOStream containing a nexus tree and convert into a phylogenetic tree of type TREE <: AbstractTree\n\n\n\n\n\nparsenexus(inp)\n\nParse some input containing a nexus tree and convert into a phylogenetic tree of type RootedTree\n\n\n\n\n\n","category":"function"},{"location":"man/io/#Phylo.Nonultrametric","page":"Creating and writing phylogenies","title":"Phylo.Nonultrametric","text":"Nonultrametric{T <: AbstractTree,\n               SAMP <: Sampleable}(n::Int,\n                                   sampleable::SAMP = Exponential())\nNonultrametric{T <: AbstractTree,\n               SAMP <: Sampleable}(tiplabels::Vector{String},\n                                   sampleable::SAMP = Exponential())\n\nThe sampler for non-ultrametric phylogenetic trees of size n or with tip labels tiplabels. Generate random trees by calling rand().\n\n\n\n\n\n","category":"type"},{"location":"man/io/#Phylo.Ultrametric","page":"Creating and writing phylogenies","title":"Phylo.Ultrametric","text":"Ultrametric{T <: AbstractTree,\n            SAMP <: Sampleable,\n            LenUnits <: Number}(n::Int,\n                                sampleable::SAMP = Exponential())\nUltrametric{T <: AbstractTree,\n            SAMP <: Sampleable,\n            LenUnits <: Number}(tiplabels::Vector{String},\n                                sampleable::SAMP = Exponential())\n\nThe sampler for ultrametric phylogenetic trees of size n or with tip labels tiplabels. Generate random trees by calling rand().\n\n\n\n\n\n","category":"type"},{"location":"man/io/#Phylo.Newick","page":"Creating and writing phylogenies","title":"Phylo.Newick","text":"Newick{T}\n\nType to specify newick format for input or output. Parameterised optionally (default Nothing) by T to allow a dictionary to specify which nodes to export and how to map their names during export.\n\n\n\n\n\n","category":"type"},{"location":"man/io/#Phylo.Nexus","page":"Creating and writing phylogenies","title":"Phylo.Nexus","text":"Nexus\n\nType to specify nexus format for input or output.\n\n\n\n\n\n","category":"type"},{"location":"functionlist/#Function-list","page":"List of functions","title":"Function list","text":"","category":"section"},{"location":"functionlist/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/treetypes/#Modules-and-data-types","page":"Phylogeny data types","title":"Modules and data types","text":"","category":"section"},{"location":"man/treetypes/#Modules","page":"Phylogeny data types","title":"Modules","text":"","category":"section"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"Modules = [Phylo]\nOrder   = [:module]","category":"page"},{"location":"man/treetypes/#Phylo.Phylo","page":"Phylogeny data types","title":"Phylo.Phylo","text":"Phylo package\n\nThe Phylo package provides some simple phylogenetics types (e.g. NamedTree) to interface to the Diversity package for measuring phylogenetic diversity. It also provides an interface to R for copying trees to and from that language and can read newick and nexus tree files (including TreeSets that contain multiple trees).\n\nFinally it also provides a standard abstract interface to phylogenetic trees, by defining AbstractNode, AbstractBranch and AbstractTree supertypes, and methods to interface to them. It also provides (through the Phylo.API submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages.\n\n\n\n\n\n","category":"module"},{"location":"man/treetypes/#Tree-sets","page":"Phylogeny data types","title":"Tree sets","text":"","category":"section"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"TreeSet","category":"page"},{"location":"man/treetypes/#Phylo.TreeSet","page":"Phylogeny data types","title":"Phylo.TreeSet","text":"TreeSet\n\nA collection of trees with the same tips.\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Tree-types","page":"Phylogeny data types","title":"Tree types","text":"","category":"section"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"This package offers a number of different types of tree, each optimised for a specific usage","category":"page"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"RecursiveTree\nLinkTree\nNamedBinaryTree\nBinaryTree\nNamedTree\nPolytomousTree\nNamedPolytomousTree","category":"page"},{"location":"man/treetypes/#Phylo.RecursiveTree","page":"Phylogeny data types","title":"Phylo.RecursiveTree","text":"struct RecursiveTree <: AbstractTree\n\nA phylogenetic tree type containing RecursiveElts as both nodes and branches, allowing navigation of the tree using only the node and branch elements.\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.LinkTree","page":"Phylogeny data types","title":"Phylo.LinkTree","text":"struct LinkTree <: AbstractTree\n\nA phylogenetic tree type containing LinkNodes and LinkBranches\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.NamedBinaryTree","page":"Phylogeny data types","title":"Phylo.NamedBinaryTree","text":"NamedBinaryTree\n\nBinary phylogenetic tree object with known leaves\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.BinaryTree","page":"Phylogeny data types","title":"Phylo.BinaryTree","text":"BinaryTree\n\nBinary phylogenetic tree object with known leaves and per node data\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.NamedTree","page":"Phylogeny data types","title":"Phylo.NamedTree","text":"NamedPolytomousTree\n\nPolytomous phylogenetic tree object with known leaves\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.PolytomousTree","page":"Phylogeny data types","title":"Phylo.PolytomousTree","text":"PolytomousTree\n\nPhylogenetic tree object with polytomous branching, and known leaves and per node data\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.NamedPolytomousTree","page":"Phylogeny data types","title":"Phylo.NamedPolytomousTree","text":"PolytomousTree\n\nPhylogenetic tree object with polytomous branching, and known leaves and per node data\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Node-and-Branch-types","page":"Phylogeny data types","title":"Node and Branch types","text":"","category":"section"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"RecursiveElt\nLinkNode\nBinaryNode\nNode\nLinkBranch\nBranch","category":"page"},{"location":"man/treetypes/#Phylo.RecursiveElt","page":"Phylogeny data types","title":"Phylo.RecursiveElt","text":"struct RecursiveElt <: AbstractElt\n\nA type for branches or nodes in a RecursiveTree, allowing navigation of the tree without using the tree object itself.\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.LinkNode","page":"Phylogeny data types","title":"Phylo.LinkNode","text":"struct LinkNode <: AbstractNode\n\nA node type that is connected by LinkBranches in a LinkTree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.BinaryNode","page":"Phylogeny data types","title":"Phylo.BinaryNode","text":"struct BinaryNode <: AbstractNode\n\nA node of strict binary phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.Node","page":"Phylogeny data types","title":"Phylo.Node","text":"struct Node <: AbstractNode\n\nA node of potentially polytomous phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.LinkBranch","page":"Phylogeny data types","title":"Phylo.LinkBranch","text":"struct LinkBranch <: AbstractBranch\n\nA branch type that connects LinkNodes in a LinkTree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.Branch","page":"Phylogeny data types","title":"Phylo.Branch","text":"Branch\n\nA branch connecting two AbstractNodes of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Iterator-types","page":"Phylogeny data types","title":"Iterator types","text":"","category":"section"},{"location":"man/treetypes/","page":"Phylogeny data types","title":"Phylogeny data types","text":"Modules = [Phylo, Phylo.API]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"man/treetypes/#Phylo.BranchIterator","page":"Phylogeny data types","title":"Phylo.BranchIterator","text":"BranchIterator\n\nThe struct representing an iterator for branches of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.BranchNameIterator","page":"Phylogeny data types","title":"Phylo.BranchNameIterator","text":"BranchNameIterator\n\nThe struct representing an iterator for branchnames of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.NodeIterator","page":"Phylogeny data types","title":"Phylo.NodeIterator","text":"NodeIterator\n\nThe struct representing an iterator for nodes of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/treetypes/#Phylo.NodeNameIterator","page":"Phylogeny data types","title":"Phylo.NodeNameIterator","text":"NodeNameIterator\n\nThe struct representing an iterator for nodenames of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"man/routes/#Routes-along-the-tree","page":"Routes along the tree","title":"Routes along the tree","text":"","category":"section"},{"location":"man/routes/","page":"Routes along the tree","title":"Routes along the tree","text":"branchhistory\nbranchfuture\nbranchroute\nnodehistory\nnodefuture\nnoderoute","category":"page"},{"location":"man/routes/#Phylo.branchhistory","page":"Routes along the tree","title":"Phylo.branchhistory","text":"branchhistory(tree::AbstractTree, node)\n\nFind the branch route between a node on a tree and its root\n\n\n\n\n\n","category":"function"},{"location":"man/routes/#Phylo.branchfuture","page":"Routes along the tree","title":"Phylo.branchfuture","text":"branchfuture(tree::AbstractTree, node)\n\nFind the branches between a node on a tree and its leaves\n\n\n\n\n\n","category":"function"},{"location":"man/routes/#Phylo.branchroute","page":"Routes along the tree","title":"Phylo.branchroute","text":"branchroute(tree::AbstractTree, node1, node2)\n\nFind the branch route between two nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"man/routes/#Phylo.nodehistory","page":"Routes along the tree","title":"Phylo.nodehistory","text":"nodehistory(tree::AbstractTree, node)\n\nFind the node route between a node on a tree and its root\n\n\n\n\n\n","category":"function"},{"location":"man/routes/#Phylo.nodefuture","page":"Routes along the tree","title":"Phylo.nodefuture","text":"nodefuture(tree::AbstractTree, node)\n\nFind the nodes between a node on a tree and its leaves\n\n\n\n\n\n","category":"function"},{"location":"man/routes/#Phylo.noderoute","page":"Routes along the tree","title":"Phylo.noderoute","text":"noderoute(tree::AbstractTree, node1, node2)\n\nFind the node route between two nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Building-and-manipulating-trees","page":"Manipulating and building phylogenies","title":"Building and manipulating trees","text":"","category":"section"},{"location":"man/manipulating/","page":"Manipulating and building phylogenies","title":"Manipulating and building phylogenies","text":"TODO: examples here are needed","category":"page"},{"location":"man/manipulating/","page":"Manipulating and building phylogenies","title":"Manipulating and building phylogenies","text":"createbranch!\ndeletebranch!\ncreatenode!\ncreatenodes!\ndeletenode!\ndroptips!\nkeeptips!","category":"page"},{"location":"man/manipulating/#Phylo.createbranch!","page":"Manipulating and building phylogenies","title":"Phylo.createbranch!","text":"createbranch!(tree::AbstractTree, src, dst[, len::Number];\n              data)\n\nAdd a branch from src to dst on tree with optional length and data. source and destination can be either nodes or nodenames.\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.deletebranch!","page":"Manipulating and building phylogenies","title":"Phylo.deletebranch!","text":"deletebranch!(tree::AbstractTree, branch)\ndeletebranch!(tree::AbstractTree, src, dst)\n\nDelete the branch branch from tree, or branch connecting src node to dst node.\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.createnode!","page":"Manipulating and building phylogenies","title":"Phylo.createnode!","text":"createnode!(tree::AbstractTree[, nodename]; data)\n\nCreate a node on a tree with optional node info.\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.createnodes!","page":"Manipulating and building phylogenies","title":"Phylo.createnodes!","text":"createnodes!(tree::AbstractTree, count::Integer)\ncreatenodes!(tree::AbstractTree, nodenames)\ncreatenodes!(tree::AbstractTree, nodedict)\n\nAdd a number of nodes, a vector with given names, or a Dict with node names and associated node info to a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.deletenode!","page":"Manipulating and building phylogenies","title":"Phylo.deletenode!","text":"deletenode!(tree::AbstractTree, node)\n\nDelete a node (or a name) from a tree\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.droptips!","page":"Manipulating and building phylogenies","title":"Phylo.droptips!","text":"droptips!(tree::AbstractTree{OneTree}, tips; keep = false)\n\nFunction to drop tips from a phylogenetic tree tree, which are found in the vector of tips or tip names, tips. keep determines whether to keep internal and root nodes that now only have one child (default is false). Internal nodes with no children will always be removed.\n\n\n\n\n\n","category":"function"},{"location":"man/manipulating/#Phylo.keeptips!","page":"Manipulating and building phylogenies","title":"Phylo.keeptips!","text":"keeptips!(tree::AbstractTree{OneTree}, tips; keep = false)\n\nFunction to keep only the tips in a phylogenetic tree, tree, that are found in the vector of tips or tip names, tips. keep determines whether to keep internal and root nodes that now only have one child (default is false). Internal nodes with no children will always be removed.\n\n\n\n\n\n","category":"function"},{"location":"man/plotting/#Plotting-phylogenetic-trees","page":"Plotting","title":"Plotting phylogenetic trees","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Phylo defines recipes for all AbstractTrees, allowing them to be plotted with  Plots.jl.","category":"page"},{"location":"man/plotting/#Keywords","page":"Plotting","title":"Keywords","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"It adds these keywords to the ones initially supported by Plots.jl:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"treetype: choosing :fan or :dendrogram determines the shape of the tree\nmarker_group: applies the group keyword to node markers\nline_group: applies the group keyword to branch lines\nshowtips: true (the default) shows the leaf names\ntipfont: a tuple defining the font to use for leaf names (default is (7,)),","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"which sets the font size to 7 - for font definitions see Plots annotation fonts","category":"page"},{"location":"man/plotting/#Example-plots","page":"Plotting","title":"Example plots","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"For this example, we will use the phylogeny of all extant hummingbird species.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Read the tree and plot it using two different treetypes. The default is :dendrogram","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using Phylo, Plots\nENV[\"GKSwstype\"]=\"nul\" # hide\ndefault(linecolor = :black, size = (400, 400)) # looks nicer with black lines\nhummers = open(parsenewick, Phylo.path(\"hummingbirds.tree\"))\nplot(hummers, size = (400, 600), showtips = false)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"For larger trees, the :fan treetype may work better","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(hummers, treetype = :fan)","category":"page"},{"location":"man/plotting/#Sorting-trees-for-plotting","page":"Plotting","title":"Sorting trees for plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Many phylogenies look more aesthetically pleasing if the descendants from each node are sorted in order of their size. This is called ladderize in some other packages.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"sort!(hummers, rev = true)\nplot(hummers, treetype = :fan)","category":"page"},{"location":"man/plotting/#Coloring-branches-or-nodes-by-a-variable","page":"Plotting","title":"Coloring branches or nodes by a variable","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"It is common in evolutionary studies to color the branches or node markers with the value of some variable. Plots already offers the keyword attributes marker_z and line_z for these uses, and they also work on Phylo objects.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"We can pass either","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"a Vector with the same number of elements as there are","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"branches / internal nodes, where the values follow a depthfirst order (because the tree is plotted in depthfirst order);","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"a Dict of node => value, with the value to be plotted for each node","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"(skipping nodes not in the Dict).","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"To demonstrate, let's start by defining a custom function for evolving a trait on the phylogeny according to Brownian motion, using the utility function map_depthfirst","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"evolve(tree) = map_depthfirst((val, node) -> val + randn(), 0., tree, Float64)\ntrait = evolve(hummers)\nplot(hummers, treetype = :fan, line_z = trait, linecolor = :RdYlBu, linewidth = 5, showtips = false)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The inbuilt facilities for sampling traits on trees on Phylo returns a Node => value Dict, which can also be passed to marker_z","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"brownsampler = BrownianTrait(hummers, \"Trait\")\nplot(hummers, \n     showtips = false, marker_z = rand(brownsampler), \n     linewidth = 2, markercolor = :RdYlBu, size = (400, 600))","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"We can also use the map_depthfirst utility function to highlight the clade descending from, e.g., Node 248. Here, the recursive function creates a vector of colors which will all be orange after encountering Node 248 but black before","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"clade_color = map_depthfirst((val, node) -> node == \"Node 248\" ? :orange : val, :black, hummers)\nplot(hummers, linecolor = clade_color, showtips = false, linewidth = 2, size = (400, 600))","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The Plots attributes related to markers (markersize, markershape etc.) will put markers on the internal nodes (or on both internal and tip nodes if a longer) vector is passed). The series_attributes keyword is also supported and behaves the same way","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(hummers, \n     size = (400, 800), \n     linecolor = :orange, linewidth = 5, \n     markersize = 10, markercolor = :steelblue, markerstrokecolor = :white,\n     series_annotations = text.(1:nnodes(hummers), 5, :center, :center, :white),\n     tipfont = (4,))","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The marker_group and line_group keywords allow plotting discrete values onto nodes or branches within the phylogeny.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Let's randomly evolve a discrete trait for temperature preference on the tree, using rand! to add the modelled values to the tree's list of node data. In addition to taking a Vector or a Dict, marker_group also accepts the name of internal node data.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"## evolve the trait and add it to the tree\nusing Random\n@enum TemperatureTrait lowTempPref midTempPref highTempPref\ntempsampler = SymmetricDiscreteTrait(hummers, TemperatureTrait, 0.4, \"Temperature\")\nrand!(tempsampler, hummers)\n\n## and plot it\nplot(hummers, showtips = false,\n   marker_group = \"Temperature\",\n    legend = :topleft, msc = :white, treetype = :fan,\n    c = [:red :blue :green])","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"map_depthfirst\nsort\nsort!","category":"page"},{"location":"man/plotting/#Phylo.map_depthfirst","page":"Plotting","title":"Phylo.map_depthfirst","text":"map_depthfirst(FUN, start, tree, eltype = nothing)\n\nApply FUN to each node in tree in depth-first order, and return the result. FUN must take two arguments, val and node,  where val is the result of applying FUN to the previous node, and node is the current node. start specifies the initial value of val, and eltype specifies the type of the return value of FUN.\n\nExamples\n\n≡≡≡≡≡≡≡≡≡≡≡ Define a function to evolve a trait on the tree according to Brownian motion\n\njulia> evolve(tree) = map_depthfirst((val, node) -> val + randn(), 0., tree, Float64)\n\n\n\n\n\n","category":"function"},{"location":"man/plotting/#Base.sort","page":"Plotting","title":"Base.sort","text":"sort(::AbstractTree; rev = false)\n\nCopies a tree and sorts its branches. See sort! for further details.\n\n\n\n\n\n","category":"function"},{"location":"man/plotting/#Base.sort!","page":"Plotting","title":"Base.sort!","text":"sort!(::AbstractTree; rev = false)\n\nSorts the branches descending from each node by total number of descendants. This creates a clearer tree for plotting. The process is also called \"ladderizing\" the tree. Use rev=true to reverse the sorting order.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API","page":"API","title":"Phylo.API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The Phylo.API submodule provides the API that must be extended for new AbstractTree, AbstractNode and AbstractBranch subtypes.","category":"page"},{"location":"api/#Usage","page":"API","title":"Usage","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Providing additional code to extend the functionality of the system is simple:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Phylo\n\nstruct SimplestTree <: AbstractTree{Int, Int}\n    nodes::OrderedDict{Int, BinaryNode{Int}}\n    branches::Dict{Int, Branch{Int}}\nend\n\nimport Phylo.API: _addnode!\nfunction _addnode!(tree::SimplestTree, num)\n    _setnode!(tree, num, BinaryNode{Int}())\n    return num\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"creates a new SimplestTree type (a subtype of AbstractTree) and extends Phylo.API._addnode!() (and therefore the directly accessible addnode!() interface) to handle the SimplestTree subtype of AbstractTree. See docs here to see which Phylo.API functions have to be extended for any new subtype, and which have default implementations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Phylo.API]","category":"page"},{"location":"api/#Phylo.API","page":"API","title":"Phylo.API","text":"Phylo.API submodule\n\nThe Phylo.API submodule should be imported if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.\n\n\n\n\n\n","category":"module"},{"location":"api/#Phylo.API._addconnection!","page":"API","title":"Phylo.API._addconnection!","text":"_addconnection!(tree::AbstractTree, node::AbstractNode, branch)\n\nAdd a connection to an unrooted node. Must be implemented for any unrooted AbstractNode subtype unless this happens when a branch is added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._addinbound!","page":"API","title":"Phylo.API._addinbound!","text":"_addinbound!(tree::AbstractTree, node::AbstractNode, inbound)\n\nAdds a branch to the input of a rooted node. Must be implemented for any rooted AbstractNode subtype unless this happens when a branch is created.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._addoutbound!","page":"API","title":"Phylo.API._addoutbound!","text":"_addoutbound!(tree::AbstractTree, node::AbstractNode, branch)\n\nAdd an outbound branch to a rooted node. Must be implemented for any Rooted AbstractNode subtype unless this happens when a branch is created.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._branchdatatype","page":"API","title":"Phylo.API._branchdatatype","text":"_branchdatatype(::Type{<:AbstractTree})\n\nReturns the type of the branch info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._branchdims","page":"API","title":"Phylo.API._branchdims","text":"_branchdims(::Type{<:AbstractTree})\n\nReturns the dimensions of the branch lengths for the tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._clearrootheight!","page":"API","title":"Phylo.API._clearrootheight!","text":"_clearrootheight!(::AbstractTree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._conn","page":"API","title":"Phylo.API._conn","text":"_conn(branch::AbstractBranch, exclude::AbstractNode)\n\nReturn the connection for a branch that isn't the exclude node. May be implemented for any Unrooted AbstractBranch subtype, otherwise will use _conns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._conns","page":"API","title":"Phylo.API._conns","text":"_conns(tree::AbstractTree, branch::AbstractBranch)\n\nReturn a vector of connections for a branch. Must be implemented for any Unrooted AbstractBranch subtype, otherwise can combine _src and _dst.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._createbranch!","page":"API","title":"Phylo.API._createbranch!","text":"_createbranch!(tree::AbstractTree, source, destination[,\n               length][, data])\n\nCreate a new branch and add it to a tree. Must be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._createnode!","page":"API","title":"Phylo.API._createnode!","text":"_createnode!(tree::AbstractTree, nodename[, data])\n\nMust be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._degree","page":"API","title":"Phylo.API._degree","text":"_degree(tree::AbstractTree, node::AbstractNode)\n\nDegree of node. Must be implemented for Unrooted nodes, otherwise can be inferred from indegree and outdegree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._deletebranch!","page":"API","title":"Phylo.API._deletebranch!","text":"_deletebranch!(tree::AbstractTree, branch)\n\nDelete a branch, reoving it from a tree. Must be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._deletenode!","page":"API","title":"Phylo.API._deletenode!","text":"_deletenode!(tree::AbstractTree, nodename)\n\nMust be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._dst","page":"API","title":"Phylo.API._dst","text":"_dst(tree::AbstractTree, branch::AbstractBranch)\n\nReturn destination node for a branch. Must be implemented for any rooted AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranch","page":"API","title":"Phylo.API._getbranch","text":"_getbranch(::AbstractTree, id)\n\nReturns the branch or name associated with id (which could be a name or a branch) from a tree. Must be implemented for any PreferBranchObjects tree and branch label type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranches","page":"API","title":"Phylo.API._getbranches","text":"_getbranches(tree::AbstractTree)\n\nReturns a vector of branches for a OneTree tree. Either _getbranches() or _getbranchnames() must be implemented for any OneTree tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranchname","page":"API","title":"Phylo.API._getbranchname","text":"_getbranchname(::AbstractTree, id)\n\nReturns the name of a branch associated with id (which could be a name or a branch) from a tree. Must be implemented for PreferBranchObjects tree types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranchnames","page":"API","title":"Phylo.API._getbranchnames","text":"_getbranchnames(tree::AbstractTree)\n\nReturns a vector of branch names for a OneTree tree. Either _getbranches() or _getbranchnames() must be implemented for any OneTree tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getchildren","page":"API","title":"Phylo.API._getchildren","text":"_getchildren(tree::AbstractTree, node)\n_getchildren(tree::AbstractTree, nodename)\n\nReturn the child node(s) for this node. May be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getconnections","page":"API","title":"Phylo.API._getconnections","text":"_getconnections(tree::AbstractTree, node::AbstractNode)\n\nReturns all of the connections of a node. Must be implemented for any unrooted AbstractNode subtype, can be inferred from _getinbound and _getoutbounds for a rooted node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getheight-Tuple{AbstractTree, Any}","page":"API","title":"Phylo.API._getheight","text":"_getheight(tree::AbstractTree, nodename)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._getinbound","page":"API","title":"Phylo.API._getinbound","text":"_getinbound(tree::AbstractTree, node::AbstractNode)\n\nGet the inbound connection. Must be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getleafnames","page":"API","title":"Phylo.API._getleafnames","text":"_getleafnames(::AbstractTree, ::TraversalOrder)\n\nReturns the leaf names of a tree. May be implemented for any tree type (otherwise determined from _getnodenames() and _isleaf() functions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getleaves","page":"API","title":"Phylo.API._getleaves","text":"_getleaves(::AbstractTree)\n\nReturns the leaves (tips) of a single tree. May be implemented for any OneTree type (otherwise determined from _getnodes() and _isleaf() functions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getlength","page":"API","title":"Phylo.API._getlength","text":"_getlength\n\nReturn length of a branch. May be implemented for any AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnode","page":"API","title":"Phylo.API._getnode","text":"_getnode(::AbstractTree, id)\n\nReturns the node or name associated with id (which could be a name or a node) from a tree. Must be implemented for any PreferNodeObjects tree and node label type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnodename","page":"API","title":"Phylo.API._getnodename","text":"_getnodename(::AbstractTree, id)\n\nReturns the name of a node associated with id (which could be a name or a node) from a tree. Must be implemented for PreferNodeObjects tree types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnodenames","page":"API","title":"Phylo.API._getnodenames","text":"_getnodenames(tree::AbstractTree{OneTree})\n\nReturns an iterable collection of node names for a OneTree tree. Can be implemented for any OneTree tree type, especially PreferNodeObjects trees.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnodes","page":"API","title":"Phylo.API._getnodes","text":"_getnodes(tree::AbstractTree{OneTree}[, order::TraversalOrder])\n\nReturns an interable collection of nodes for a OneTree tree. _getnodes(tree) must be implemented for a OneTree tree type as a base mechanisms for extracting the node list.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getoutbounds","page":"API","title":"Phylo.API._getoutbounds","text":"_getoutbounds(tree::AbstractTree, node::AbstractNode)\n\nReturns the outbound connections of a rooted node. Must be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getparent","page":"API","title":"Phylo.API._getparent","text":"_getparent(tree::AbstractTree, node)\n\nReturn the parent node for this node. Can be implemented for Rooted node types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getroot","page":"API","title":"Phylo.API._getroot","text":"_getroot(::AbstractTree)\n\nReturns the unique root of a rooted tree. May be implemented for any OneTree type (otherwise determined from _getroots()).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getrootheight","page":"API","title":"Phylo.API._getrootheight","text":"_getrootheight(::AbstractTree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getroots-Tuple{AbstractTree{OneTree, var\"#s31\", NL, Node, Branch} where {var\"#s31\"<:Phylo.Rooted, NL, Node<:Phylo.AbstractElt{var\"#s31\", NL}, Branch<:Phylo.AbstractElt{var\"#s31\", NL}}}","page":"API","title":"Phylo.API._getroots","text":"_getroots(::AbstractTree)\n\nReturns the root(s) of a tree. May be implemented for any OneTree type (otherwise determined from _getnodes() and _isroot() functions).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._getsiblings","page":"API","title":"Phylo.API._getsiblings","text":"_getsiblings(tree::AbstractTree, node::AbstractNode)\n\nReturns all of the siblings (actually immediate connections) of a node. May be implemented for any AbstractNode subtype, can be inferred from _getparent and _getchildren for a rooted node or _getconnections for an unrooted node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettree","page":"API","title":"Phylo.API._gettree","text":"_gettree(::Pair{Label, AbstractTree})\n_gettree(::AbstractTree, id)\n\nReturns a tree - either itself if it is a single tree, or the single tree in a set with label id. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreeinfo","page":"API","title":"Phylo.API._gettreeinfo","text":"_gettreeinfo(tree::AbstractTree)\n_gettreeinfo(tree::AbstractTree, treename)\n\nReturns the info data associated with the tree(s).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreename","page":"API","title":"Phylo.API._gettreename","text":"_gettreename(::AbstractTree)\n\nReturns the name for a single tree. Should be implemented for any OneTree type where they have names.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreenames","page":"API","title":"Phylo.API._gettreenames","text":"_gettreenames(::AbstractTree)\n\nReturns the names for the trees. Can be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettrees","page":"API","title":"Phylo.API._gettrees","text":"_gettrees(::AbstractTree)\n\nReturns the trees in an object. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasbranch","page":"API","title":"Phylo.API._hasbranch","text":"_hasbranch(tree::AbstractTree, node[name])\n\nDoes the tree contain this branch? Must be implemented for any PreferBranchObjects tree type with a branch label.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasheight-Tuple{AbstractTree, Any}","page":"API","title":"Phylo.API._hasheight","text":"_hasheight(tree::AbstractTree, nodename)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._hasinbound","page":"API","title":"Phylo.API._hasinbound","text":"_hasinbound(tree::AbstractTree, node::AbstractNode)\n\nMust be implemented for any AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasinboundspace","page":"API","title":"Phylo.API._hasinboundspace","text":"_hasinboundspace(tree::AbstractTree, node::AbstractNode)\n\nIs there space for a new inbound connection on a node?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._haslength","page":"API","title":"Phylo.API._haslength","text":"_haslength\n\nReturn length of a branch. May be implemented for any AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasnode","page":"API","title":"Phylo.API._hasnode","text":"_hasnode(tree::AbstractTree, node[name])\n\nDoes the tree contain this node? Must be implemented for any PreferNodeObjects tree type with a node label.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasoutboundspace","page":"API","title":"Phylo.API._hasoutboundspace","text":"_hasoutboundspace(tree::AbstractTree, node::AbstractNode)\n\nIs there space for a new outbound connection on a node? Must be implemented if a node has a limit on the number of outbound connections (eg for a binary tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasrootheight-Tuple{AbstractTree}","page":"API","title":"Phylo.API._hasrootheight","text":"_hasrootheight(::AbstractTree)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._hasspace","page":"API","title":"Phylo.API._hasspace","text":"_hasspace(tree::AbstractTree, node::AbstractNode)\n\nIs there space for a new connection on a node? Must be implemented if a node has a limit on the number of connections (eg for a binary tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._indegree","page":"API","title":"Phylo.API._indegree","text":"_indegree(tree::AbstractTree, node)\n\nIn degree of node. Can be implemented for rooted nodes, otherwise inferred from _hasinbound.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._invalidate!","page":"API","title":"Phylo.API._invalidate!","text":"_invalidate!(::AbstractTree, state)\n\nConfirm that the tree is no longer necessarily valid, and remove cache information.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isinternal","page":"API","title":"Phylo.API._isinternal","text":"_isinternal(tree::AbstractTree, node)\n\nIs the node internal to the tree?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isleaf","page":"API","title":"Phylo.API._isleaf","text":"_isleaf(tree::AbstractTree, node)\n\nIs the node a leaf? Does not need to be implemented for any node type – inferred from _outdegree or _degree - unless tree knows which nodes are leaves and not nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isroot","page":"API","title":"Phylo.API._isroot","text":"_isroot(tree::AbstractTree, node)\n\nIs the node a root node of the tree?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isunattached-Tuple{AbstractTree, Any}","page":"API","title":"Phylo.API._isunattached","text":"_isunattached(tree::AbstractTree, node)\n\nDoes the node currently form its own (sub)tree?\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._leafinfotype","page":"API","title":"Phylo.API._leafinfotype","text":"_leafinfotype(::Type{<:AbstractTree})\n\nReturns the type of the leaf info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._matchbranchnodetype","page":"API","title":"Phylo.API._matchbranchnodetype","text":"_matchbranchnodetype(::Type{<:AbstractTree},\n                     ::Type{<:AbstractBranch},\n                     ::Type{<:AbstractNode})\n\nDoes this tree type prefer the branch and node types provided?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._matchbranchtype","page":"API","title":"Phylo.API._matchbranchtype","text":"_matchbranchtype(::Type{<:AbstractTree}, ::Type{<:AbstractBranch})\n\nDoes this tree type prefer the branch or branch label type provided?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._matchnodetype","page":"API","title":"Phylo.API._matchnodetype","text":"_matchnodetype(::Type{<:AbstractTree{TT, RT, NL, N, B}}, ::Type{N})\n_matchnodetype(::Type{<:AbstractTree{TT, RT, NL, N, B}}, ::Type{NL})\n\nDoes this tree type prefer the node or node label type provided?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._matchtreenametype-Union{Tuple{TN}, Tuple{T}, Tuple{Type{T}, Type{TN}}} where {T<:AbstractTree, TN}","page":"API","title":"Phylo.API._matchtreenametype","text":"_matchtreenametype(::Type{<:AbstractTree}, ::Type{X})\n\nDoes this tree type prefer the node or node label type provided?\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._nbranches-Tuple{AbstractTree{OneTree, RT, NL} where {RT<:Phylo.Rootedness, NL}}","page":"API","title":"Phylo.API._nbranches","text":"_nbranches(::AbstractTree)\n\nReturns the number of branches in a single tree. May be implemented for any OneTree tree type (otherwise infers from _getbranches()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._newbranchlabel","page":"API","title":"Phylo.API._newbranchlabel","text":"_newbranchlabel(tree::AbstractTree)\n\nReturns a new unique branch name for a tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._newnodelabel","page":"API","title":"Phylo.API._newnodelabel","text":"_newnodelabel(tree::AbstractTree)\n\nReturns a new unique node name for a tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._nleaves-Tuple{AbstractTree}","page":"API","title":"Phylo.API._nleaves","text":"_nleaves(::AbstractTree)\n\nReturns the number of leaves (tips) in a tree. May be implemented for any tree type (otherwise determined from the _getleafnames() function).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._nnodes-Tuple{AbstractTree{OneTree, RT, NL} where {RT<:Phylo.Rootedness, NL}}","page":"API","title":"Phylo.API._nnodes","text":"_nnodes(::AbstractTree)\n\nReturns the number of nodes (internal nodes and leaves) in a single tree. May be implemented for any OneTree tree type (otherwise infers from _getnodes()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._nodedatatype","page":"API","title":"Phylo.API._nodedatatype","text":"_nodedatatype(::Type{<:AbstractTree})\n\nReturns the type of the node info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._nroots","page":"API","title":"Phylo.API._nroots","text":"_nroots(::AbstractTree)\n\nReturns the number of roots (subtrees) in a OneTree tree. May be implemented for any ManyRoots type (otherwise infers from _getroots()).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._ntrees","page":"API","title":"Phylo.API._ntrees","text":"_ntrees(::AbstractTree)\n\nReturns the number of trees in an object. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._outdegree","page":"API","title":"Phylo.API._outdegree","text":"_outdegree(tree::AbstractTree, node::AbstractNode)\n\nOut degree of node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._preferbranchobjects","page":"API","title":"Phylo.API._preferbranchobjects","text":"_preferbranchobjects(::Type{<:AbstractTree})\n\nDoes this tree or branch type prefer branches to be objects or names? Must be implemented for every branch type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._prefernodeobjects","page":"API","title":"Phylo.API._prefernodeobjects","text":"_prefernodeobjects(::Type{<:AbstractTree})\n\nDoes this tree or node type prefer nodes to be objects or names? Must be implemented for every node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeconnection!","page":"API","title":"Phylo.API._removeconnection!","text":"_removeconnection!(tree::AbstractTree, node::AbstractNode, branch)\n\nRemove a connection from an unrooted node. Must be implemented for any Unrooted AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeinbound!","page":"API","title":"Phylo.API._removeinbound!","text":"_removeinbound!(tree::AbstractTree, node::AbstractNode, inbound)\n\nRemoves a branch from the input of a rooted node. Must be implemented for any rooted AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeoutbound!","page":"API","title":"Phylo.API._removeoutbound!","text":"_removeoutbound!(tree::AbstractTree, node::AbstractNode, branch)\n\nRemove an outbound branch from a rooted node. Must be implemented for any AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._renamenode!","page":"API","title":"Phylo.API._renamenode!","text":"_renamenode!(tree::AbstractTree, oldnode[name], newname)\n\nRenames a node in a tree. Optional - not implemented for most tree types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._resetleaves!","page":"API","title":"Phylo.API._resetleaves!","text":"_resetleaves!(::AbstractTree)\n\nFixes leaf naming after creation or deletion of nodes or branches. Must be implemented by tree types where this is handled separately.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._setheight!-Tuple{AbstractTree, Any, Any}","page":"API","title":"Phylo.API._setheight!","text":"_setheight!(::AbstractTree, nodename, value)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._setrootheight!","page":"API","title":"Phylo.API._setrootheight!","text":"_setrootheight!(::AbstractTree, value)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._src","page":"API","title":"Phylo.API._src","text":"_src(tree, branch)\n\nReturn source node for a branch. Must be implemented for any rooted branch type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._traversal","page":"API","title":"Phylo.API._traversal","text":"_traversal(tree::AbstractTree, order::TraversalOrder, todo, sofar)\n\nReturn an iterable object containing nodes in given order - preorder, inorder, postorder or breadthfirst\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._treenametype","page":"API","title":"Phylo.API._treenametype","text":"_treenametype(::Type{AbstractTree})\n\nReturns the label type for a tree type. Must be implemented for any tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._validate!","page":"API","title":"Phylo.API._validate!","text":"_validate!(::AbstractTree)\n\nCheck whether the tree is internally valid.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"man/modelling/#Modelling-traits-on-trees","page":"Modelling traits","title":"Modelling traits on trees","text":"","category":"section"},{"location":"man/modelling/","page":"Modelling traits","title":"Modelling traits","text":"BrownianTrait\nDiscreteTrait\nSymmetricDiscreteTrait","category":"page"},{"location":"man/modelling/#Phylo.BrownianTrait","page":"Modelling traits","title":"Phylo.BrownianTrait","text":"BrownianTrait{T <: AbstractTree, N <: Number}\n\nA continuous trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(). The trait to be evolved can be any continuous numeric type, including Unitful types for instance, and in the simplest case is determined by the third argument to the constructor start:\n\nfunction BrownianTrait(tree::AbstractTree, trait::String, start::Number = 0.0;                        σ² = missing, σ = missing, f::Function = identity)\n\nNote that when Unitful is being used, either here or in branch lengths, σ/σ² keyword argument units must be appropriate. The final keyword argument, f, is a function to transform the evolved gaussian trait into its true value. By default this is the identity function, but can, for instance, be abs to force a positive value on the trait, or more complex functions as required, such as a transformation to turn a continuous variable into a discrete trait\n\n\n\n\n\n","category":"type"},{"location":"man/modelling/#Phylo.DiscreteTrait","page":"Modelling traits","title":"Phylo.DiscreteTrait","text":"DiscreteTrait{T <: AbstractTree, E <: Enum}\n\nA discrete trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(dt). The trait to be evolved must be an Enum (generally created using @enum), and is the second argument to the constructor:\n\nfunction DiscreteTrait(tree::AbstractTree, ttype::Type{<:Enum},                        transition_matrix::AbstractMatrix{Float64},                        trait::String)\n\nThe transition matrix holds transition rates from row to column (so row sums must be zero), and the transition probabilities in a branch are calculated as exp(transition_matrix .* branch_length).\n\n\n\n\n\n","category":"type"},{"location":"man/modelling/#Phylo.SymmetricDiscreteTrait","page":"Modelling traits","title":"Phylo.SymmetricDiscreteTrait","text":"SymmetricDiscreteTrait{T <: AbstractTree, E <: Enum}\n\nThe simplest possible discrete trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(sdt). The trait to be evolved must be an Enum (generally created using @enum), and is the second argument to the constructor:\n\nfunction DiscreteTrait(tree::AbstractTree, ttype::Type{<:Enum},                        transition_rate::Number,                        trait::String)\n\nThe transition matrix holds transition rates from row to column (so row sums must be zero), and the transition probabilities in a branch are calculated as exp(transition_matrix .* branch_length).\n\n\n\n\n\n","category":"type"},{"location":"man/traversal/#Traversing-and-iterating-over-trees","page":"Traversal and iterators","title":"Traversing and iterating over trees","text":"","category":"section"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"The code also provides iterators, and filtered iterators over the branches, nodes, branchnames and nodenames of a tree (using the random tree from Creating and writing phylogenies)","category":"page"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"using Phylo\nnu = Nonultrametric(5);\ntree = rand(nu)\n\ncollect(nodeiter(tree))","category":"page"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"collect(nodenamefilter(isroot, tree))","category":"page"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"TreeSets are iterators themselves","category":"page"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"trees = rand(nu, [\"Tree 1\", \"Tree 2\"])\ncollect(trees)","category":"page"},{"location":"man/traversal/","page":"Traversal and iterators","title":"Traversal and iterators","text":"nodeiter\nnodefilter\nnodenameiter\nnodenamefilter\nbranchiter\nbranchfilter\nbranchnameiter\nbranchnamefilter\ntraversal","category":"page"},{"location":"man/traversal/#Phylo.nodeiter","page":"Traversal and iterators","title":"Phylo.nodeiter","text":"nodeiter(tree::AbstractTree)\n\nReturns an iterator over the nodes of any tree.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.nodefilter","page":"Traversal and iterators","title":"Phylo.nodefilter","text":"nodefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the nodes of any tree, where the AbstractNode is filtered by the function filterfn.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.nodenameiter","page":"Traversal and iterators","title":"Phylo.nodenameiter","text":"nodenameiter(tree::AbstractTree)\n\nReturns an iterator over the names of the nodes of any tree.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.nodenamefilter","page":"Traversal and iterators","title":"Phylo.nodenamefilter","text":"nodenamefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the nodenames of any tree, where the AbstractNode itself is filtered by the function filterfn.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.branchiter","page":"Traversal and iterators","title":"Phylo.branchiter","text":"branchiter(tree::AbstractTree)\n\nReturns an iterator over the branches of any tree.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.branchfilter","page":"Traversal and iterators","title":"Phylo.branchfilter","text":"branchfilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the branches of any tree, where the AbstractBranch is filtered by the function filterfn.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.branchnameiter","page":"Traversal and iterators","title":"Phylo.branchnameiter","text":"branchnameiter(tree::AbstractTree)\n\nReturns an iterator over the names of branches of any tree.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.branchnamefilter","page":"Traversal and iterators","title":"Phylo.branchnamefilter","text":"branchnamefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the names of the branches of any tree, where the AbstractBranch is filtered by the function filterfn.\n\n\n\n\n\n","category":"function"},{"location":"man/traversal/#Phylo.traversal","page":"Traversal and iterators","title":"Phylo.traversal","text":"traversal(::AbstractTree, ::TraversalOrder)\ntraversal(::AbstractTree, ::TraversalOrder, init)\n\nReturn an iterable object for a tree containing nodes in given order - anyorder, preorder, inorder, postorder or breadthfirst - optionally starting from init.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Getting-tree-attributes","page":"Getting phylogeny attributes","title":"Getting tree attributes","text":"","category":"section"},{"location":"man/attributes/#Methods-on-TreeSets","page":"Getting phylogeny attributes","title":"Methods on TreeSets","text":"","category":"section"},{"location":"man/attributes/","page":"Getting phylogeny attributes","title":"Getting phylogeny attributes","text":"ntrees\ngettree\ngettrees\nnroots\ngetroots\ngettreenames","category":"page"},{"location":"man/attributes/#Phylo.ntrees","page":"Getting phylogeny attributes","title":"Phylo.ntrees","text":"ntrees(tree::AbstractTree)\n\nReturns the number of trees in a tree object, 1 for a OneTree tree type, and the count of trees for a ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.gettree","page":"Getting phylogeny attributes","title":"Phylo.gettree","text":"gettree(tree::AbstractTree, label)\n\nReturns a single OneTree object tree corresponding to the label given.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.gettrees","page":"Getting phylogeny attributes","title":"Phylo.gettrees","text":"gettrees(tree::AbstractTree)\n\nReturns an iterable of trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nroots","page":"Getting phylogeny attributes","title":"Phylo.nroots","text":"nroots(::AbstractTree)\n\nReturns the number of roots in a tree. For OneTree types, Unrooted trees will return 0, OneRoot trees should return 1, and manyroots tree (ones with multiple subtrees) will return the number of subtrees. ManyTrees types will return a Dict of counts of the number of roots for each tree in the set.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getroots","page":"Getting phylogeny attributes","title":"Phylo.getroots","text":"getroots(::AbstractTree)\ngetroots(::AbstractTree, id)\n\nReturns a vector containing the root(s) of a single (OneTree) tree or a set of (ManyTrees) trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.gettreenames","page":"Getting phylogeny attributes","title":"Phylo.gettreenames","text":"gettreenames(tree::AbstractTree)\n\nReturns the names of the trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Methods-on-Trees","page":"Getting phylogeny attributes","title":"Methods on Trees","text":"","category":"section"},{"location":"man/attributes/","page":"Getting phylogeny attributes","title":"Getting phylogeny attributes","text":"mrca\nnodeheights\ngetleafnames\ngetleaves\nnleaves\nnnodes\nninternal\nnbranches\ndistance\ndistances\nheighttoroot\nheightstoroot\ngetroot\ntreenametype\ngettreename\nroottype\nnodetype\nnodedatatype\nnodenametype\nbranchtype\nbranchdatatype\nbranchnametype\ngetnodenames\ngetnodename\nhasnode\ngetnode\ngetnodes\ngetinternalnodes\ngetbranchnames\ngetbranchname\nhasbranch\ngetbranch\ngetbranches\ngettreeinfo\nvalidate!\ninvalidate!\nbranchdims\ntreetype\ntreesettype","category":"page"},{"location":"man/attributes/#Phylo.mrca","page":"Getting phylogeny attributes","title":"Phylo.mrca","text":"mrca(tree::AbstractTree, target)\n\nReturns the node within tree that is the Most Recent Common Ancestor of the leaves (or internal nodes) defined by target. target can be an iterator over nodes or an AbstractArray of nodes. The return value has the same node type as the elements of target.\n\nExamples\n\n≡≡≡≡≡≡≡≡≡≡≡\n\njulia> tree = open(parsenewick, Phylo.path(\"H1N1.newick\")) RootedTree with 507 tips, 1013 nodes and 1012 branches. Leaf names are 227, 294, 295, 110, 390, ... [501 omitted] ... and 418\n\njulia> tips = rand(collect(nodefilter(isleaf, tree)), 3) 3-element Vector{RecursiveNode{OneRoot, String, Dict{String, Any}, Dict{String, Any}, PolytomousBranching, Float64}}:  leaf node '414'  leaf node '232'  leaf node '216'\n\njulia> mrca(tree, tips) internal node 'Node 980'\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nodeheights","page":"Getting phylogeny attributes","title":"Phylo.nodeheights","text":"nodeheights(tree::Phylo.AbstractTree; onlyleaves = false, noleaves = false)\n\nReturns an AxisArray of the height of all nodes in tree over the root node. onlyleaves and noleaves filter the nodes for leaves and internal nodes, respectively\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getleafnames","page":"Getting phylogeny attributes","title":"Phylo.getleafnames","text":"getleafnames(::AbstractTree[, ::TraversalOrder])\n\nRetrieve the leaf names from the tree (in some specific order).\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getleaves","page":"Getting phylogeny attributes","title":"Phylo.getleaves","text":"getleaves(::AbstractTree[, ::TraversalOrder])\n\nRetrieve the leaves from the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nleaves","page":"Getting phylogeny attributes","title":"Phylo.nleaves","text":"nleaves(::AbstractTree)\n\nReturns the number of leaves (tips) in a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nnodes","page":"Getting phylogeny attributes","title":"Phylo.nnodes","text":"nnodes(::AbstractTree)\n\nReturns the number of nodes of a single tree, or a Dict of numbers of nodes for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.ninternal","page":"Getting phylogeny attributes","title":"Phylo.ninternal","text":"ninternal(::AbstractTree)\n\nReturns the number of internal nodes of a single tree, or a Dict of numbers of nodes for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nbranches","page":"Getting phylogeny attributes","title":"Phylo.nbranches","text":"nbranches(::AbstractTree)\n\nReturns the number of branches of a single tree, or a Dict of numbers of branches for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.distance","page":"Getting phylogeny attributes","title":"Phylo.distance","text":"distance(tree::AbstractTree, node1, node2)\n\nDistance between two nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.distances","page":"Getting phylogeny attributes","title":"Phylo.distances","text":"distances(tree::AbstractTree)\n\nPairwise distances between all leaf nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.heighttoroot","page":"Getting phylogeny attributes","title":"Phylo.heighttoroot","text":"heighttoroot(tree::AbstractTree, node)\n\nHeight of a node of the tree above the root\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.heightstoroot","page":"Getting phylogeny attributes","title":"Phylo.heightstoroot","text":"heightstoroot(tree::AbstractTree)\n\nHeight of all of the leaves of the tree above the root\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getroot","page":"Getting phylogeny attributes","title":"Phylo.getroot","text":"getroot(::AbstractTree)\n\nReturns the root of a single tree (must be only one tree for a ManyTrees tree).\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.treenametype","page":"Getting phylogeny attributes","title":"Phylo.treenametype","text":"treenametype(::Type{AbstractTree})\n\nReturns the name type for a tree type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.gettreename","page":"Getting phylogeny attributes","title":"Phylo.gettreename","text":"gettreename(tree::AbstractTree)\n\nReturns the name of the single tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.roottype","page":"Getting phylogeny attributes","title":"Phylo.roottype","text":"roottype(::Type{AbstractTree})\nroottype(::Type{AbstractElt})\n\nReturns root type from a tree, node, branch or other element type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nodetype","page":"Getting phylogeny attributes","title":"Phylo.nodetype","text":"nodetype(::Type{AbstractTree})\n\nReturns type of nodes from a tree type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nodedatatype","page":"Getting phylogeny attributes","title":"Phylo.nodedatatype","text":"nodedatatype(::Type{<: AbstractTree})\n\nretrieve the node info type of a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.nodenametype","page":"Getting phylogeny attributes","title":"Phylo.nodenametype","text":"nodenametype(::Type{AbstractTree})\nnodenametype(::Type{AbstractElt})\n\nReturns type of node names from a tree type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.branchtype","page":"Getting phylogeny attributes","title":"Phylo.branchtype","text":"branchtype(::Type{AbstractTree})\n\nReturns type of branches from a tree type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.branchdatatype","page":"Getting phylogeny attributes","title":"Phylo.branchdatatype","text":"branchdatatype(::Type{<: AbstractTree})\n\nretrieve the branch info type of a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.branchnametype","page":"Getting phylogeny attributes","title":"Phylo.branchnametype","text":"branchnametype(::AbstractTree)\n\nReturns type of branch names from a branch type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getnodenames","page":"Getting phylogeny attributes","title":"Phylo.getnodenames","text":"getnodenames(::AbstractTree[, ::TraversalOrder])\n\nReturn a vector of node names of a single tree (identified by id for a ManyTrees tree), or a Dict of vectors of node names for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getnodename","page":"Getting phylogeny attributes","title":"Phylo.getnodename","text":"getnodename(::AbstractTree, node)\n\nReturns the node name associated with a node from a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasnode","page":"Getting phylogeny attributes","title":"Phylo.hasnode","text":"hasnode(tree::AbstractTree, node)\n\nReturns whether a tree has a given node (or node name) or not.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getnode","page":"Getting phylogeny attributes","title":"Phylo.getnode","text":"getnode(tree::AbstractTree, node[name])\n\nReturns a node from a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getnodes","page":"Getting phylogeny attributes","title":"Phylo.getnodes","text":"getnodes(::AbstractTree[, ::TraversalOrder])\n\nReturns the vector of nodes of a single tree, or a Dict of vectors of nodes for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getinternalnodes","page":"Getting phylogeny attributes","title":"Phylo.getinternalnodes","text":"getinternalnodes(t::AbstractTree)\n\nFunction to retrieve only the internal nodes from a tree, t, which does not include tips or root.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getbranchnames","page":"Getting phylogeny attributes","title":"Phylo.getbranchnames","text":"getbranchnames(tree::AbstractTree)\n\nReturn a vector of branch names of a single tree, or a Dict of vectors of branch names for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getbranchname","page":"Getting phylogeny attributes","title":"Phylo.getbranchname","text":"getbranchname(::AbstractTree, branch)\ngetbranchname(branch)\n\nReturns the branch name associated with a branch from a tree. For some branch types, it will be able to extract the branch name without reference to the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasbranch","page":"Getting phylogeny attributes","title":"Phylo.hasbranch","text":"hasbranch(tree::AbstractTree, branch)\nhasbranch(tree::AbstractTree, source, dest)\n\nDoes tree have a branch branch or a branch from source to dest?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getbranch","page":"Getting phylogeny attributes","title":"Phylo.getbranch","text":"getbranch(tree::AbstractTree, branch)\ngetbranch(tree::AbstractTree, source, dest)\n\nReturns a branch from a tree by name or by source and destination node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getbranches","page":"Getting phylogeny attributes","title":"Phylo.getbranches","text":"getbranches(::AbstractTree)\n\nReturns the vector of branches of a single tree, or a Dict of vectors of branches for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.gettreeinfo","page":"Getting phylogeny attributes","title":"Phylo.gettreeinfo","text":"gettreeinfo(tree::AbstractTree)\ngettreeinfo(tree::AbstractTree, treename)\n\nReturns the info data associated with the tree(s).\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.validate!","page":"Getting phylogeny attributes","title":"Phylo.validate!","text":"validate!(tree::AbstractTree)\n\nValidate the tree by making sure that it is connected up correctly.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.invalidate!","page":"Getting phylogeny attributes","title":"Phylo.invalidate!","text":"invalidate!(tree::AbstractTree, state = missing)\n\nConfirm that the tree is no longer necessarily valid, and remove cache information.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.branchdims","page":"Getting phylogeny attributes","title":"Phylo.branchdims","text":"branchdims(::Type{<: AbstractTree})\n\nretrieve the dimensions of the branch lengths for the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.treetype","page":"Getting phylogeny attributes","title":"Phylo.treetype","text":"treetype(::Type{AbstractTree})\n\nReturns tree number (OneTree, ManyTrees) from a tree type.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.treesettype","page":"Getting phylogeny attributes","title":"Phylo.treesettype","text":"treesettype(::Type{AbstractTree}, ::Type{LABEL} = String)\n\nReturns type of a TreeSet containing a collection of trees, from those trees' type and the type of label used to identify trees.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Methods-on-Nodes","page":"Getting phylogeny attributes","title":"Methods on Nodes","text":"","category":"section"},{"location":"man/attributes/","page":"Getting phylogeny attributes","title":"Getting phylogeny attributes","text":"isleaf\nisroot\nisinternal\nisunattached\ndegree\nindegree\noutdegree\nhasinbound\ngetinbound\ngetoutbounds\ngetconnections\nhasoutboundspace\nhasinboundspace\ngetleafinfo\nsetleafinfo!\nleafinfotype\ngetnodedata\nsetnodedata!\nhasheight\ngetheight\nsetheight!\ngetparent\ngetancestors\ngetchildren\ngetdescendants\ngetsiblings\nrenamenode!","category":"page"},{"location":"man/attributes/#Phylo.isleaf","page":"Getting phylogeny attributes","title":"Phylo.isleaf","text":"isleaf(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) a leaf of the tree?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.isroot","page":"Getting phylogeny attributes","title":"Phylo.isroot","text":"isroot(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) a root of the tree?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.isinternal","page":"Getting phylogeny attributes","title":"Phylo.isinternal","text":"isinternal(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) internal to the tree (neither root nor leaf)?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.isunattached","page":"Getting phylogeny attributes","title":"Phylo.isunattached","text":"isunattached(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) unattached (i.e. not connected to other nodes)?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Graphs.degree","page":"Getting phylogeny attributes","title":"Graphs.degree","text":"degree(tree::AbstractTree, node)\n\nReturn the degree of a node including all connections.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Graphs.indegree","page":"Getting phylogeny attributes","title":"Graphs.indegree","text":"indegree(tree::AbstractTree, node)\n\nReturn in degree of node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Graphs.outdegree","page":"Getting phylogeny attributes","title":"Graphs.outdegree","text":"outdegree(tree::AbstractTree, node)\n\nReturn out degree of node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasinbound","page":"Getting phylogeny attributes","title":"Phylo.hasinbound","text":"hasinbound(tree::AbstractTree, node)\n\nDoes the node have an inbound connection?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getinbound","page":"Getting phylogeny attributes","title":"Phylo.getinbound","text":"getinbound(tree::AbstractTree, node)\n\nreturn the inbound branch to this node (returns name for node name, branch for node).\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getoutbounds","page":"Getting phylogeny attributes","title":"Phylo.getoutbounds","text":"getoutbounds(tree::AbstractTree, nodename)\n\nReturn the names of the outbound branches from this node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getconnections","page":"Getting phylogeny attributes","title":"Phylo.getconnections","text":"getconnections(tree::AbstractTree, node, exclude = [])\n\nReturns all of the branches connected to a node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasoutboundspace","page":"Getting phylogeny attributes","title":"Phylo.hasoutboundspace","text":"hasoutboundspace(tree::AbstractTree, node)\n\nDoes the node have space for an[other] outbound connection?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasinboundspace","page":"Getting phylogeny attributes","title":"Phylo.hasinboundspace","text":"hasinboundspace(tree::AbstractTree, node)\n\nDoes the node have space for an inbound connection?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getleafinfo","page":"Getting phylogeny attributes","title":"Phylo.getleafinfo","text":"getleafinfo(::AbstractTree[, label])\n\nretrieve the leaf info for a leaf of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.setleafinfo!","page":"Getting phylogeny attributes","title":"Phylo.setleafinfo!","text":"setleafinfo!(::AbstractTree, table)\n\nSet the leaf info for the leaves of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.leafinfotype","page":"Getting phylogeny attributes","title":"Phylo.leafinfotype","text":"leafinfotype(::Type{<: AbstractTree})\n\nretrieve the leaf info type of a tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getnodedata","page":"Getting phylogeny attributes","title":"Phylo.getnodedata","text":"getnodedata(::AbstractTree, node)\n\nretrieve the node data for a node of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.setnodedata!","page":"Getting phylogeny attributes","title":"Phylo.setnodedata!","text":"setnodedata!(::AbstractTree, node, label, value)\nsetnodedata!(::AbstractTree, node, data)\n\nSet the node data for a node of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasheight","page":"Getting phylogeny attributes","title":"Phylo.hasheight","text":"hasheight(tree::AbstractTree, node)\n\nDoes the node have a height defined?\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getheight","page":"Getting phylogeny attributes","title":"Phylo.getheight","text":"getheight(tree::AbstractTree, node)\n\nReturn the height of the node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.setheight!","page":"Getting phylogeny attributes","title":"Phylo.setheight!","text":"setheight!(tree::AbstractTree, nodename, height)\n\nSet the height of the node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getparent","page":"Getting phylogeny attributes","title":"Phylo.getparent","text":"getparent(tree::AbstractTree, node)\n\nReturn [the name of] the parent node for this node [name]. Second method may not be implemented for some node types.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getancestors","page":"Getting phylogeny attributes","title":"Phylo.getancestors","text":"getancestors(tree::AbstractTree, node)\n\nReturn the name of all of the nodes that are ancestral to this node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getchildren","page":"Getting phylogeny attributes","title":"Phylo.getchildren","text":"getchildren(tree::AbstractTree, node)\n\nReturn the [name(s) of] the child node(s) for this node [name].\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getdescendants","page":"Getting phylogeny attributes","title":"Phylo.getdescendants","text":"getdescendants(tree::AbstractTree, node)\n\nReturn the names of all of the nodes that descend from this node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getsiblings","page":"Getting phylogeny attributes","title":"Phylo.getsiblings","text":"getsiblings(tree::AbstractTree, node)\n\nReturns all of the siblings of a node. Must be implemented for any unrooted AbstractNode subtype, can be inferred from _getparent and _getchildren for a rooted node.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.renamenode!","page":"Getting phylogeny attributes","title":"Phylo.renamenode!","text":"renamenode!(tree::AbstractTree, oldnode[name], newname)\n\nRenames a node in a tree. Optional - not implemented for most tree types and returns false.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Methods-on-Branches","page":"Getting phylogeny attributes","title":"Methods on Branches","text":"","category":"section"},{"location":"man/attributes/","page":"Getting phylogeny attributes","title":"Getting phylogeny attributes","text":"src\ndst\nconn\nconns\nhaslength\ngetlength\nhasrootheight\ngetrootheight\nsetrootheight!\ngetbranchdata\nsetbranchdata!","category":"page"},{"location":"man/attributes/#Graphs.src","page":"Getting phylogeny attributes","title":"Graphs.src","text":"src(tree::AbstractTree, branch)\n\nReturn the source node for this branch.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Graphs.dst","page":"Getting phylogeny attributes","title":"Graphs.dst","text":"dst(tree::AbstractTree, branch)\n\nReturn the destination node for this branch.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.conn","page":"Getting phylogeny attributes","title":"Phylo.conn","text":"conn(tree::AbstractTree, branch, exclude)\n\nReturn the other node connected to branch that is not exclude.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.conns","page":"Getting phylogeny attributes","title":"Phylo.conns","text":"conns(tree::AbstractTree, branch)\n\nReturn the nodes connected to branch.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.haslength","page":"Getting phylogeny attributes","title":"Phylo.haslength","text":"haslength(tree::AbstractTree, branch)\n\nReturn whether the branch has a length.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getlength","page":"Getting phylogeny attributes","title":"Phylo.getlength","text":"getlength(tree::AbstractTree, branch)\n\nReturn the length of this branch.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.hasrootheight","page":"Getting phylogeny attributes","title":"Phylo.hasrootheight","text":"hasrootheight(tree::AbstractTree)\n\nDoes the tree have an explicit root height\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getrootheight","page":"Getting phylogeny attributes","title":"Phylo.getrootheight","text":"getrootheight(tree::AbstractTree)\n\nGet the tree's root height.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.setrootheight!","page":"Getting phylogeny attributes","title":"Phylo.setrootheight!","text":"setrootheight!(tree::AbstractTree, height)\n\nSet the tree's root height.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.getbranchdata","page":"Getting phylogeny attributes","title":"Phylo.getbranchdata","text":"getbranchdata(::AbstractTree, label)\n\nretrieve the branch data for a leaf of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/attributes/#Phylo.setbranchdata!","page":"Getting phylogeny attributes","title":"Phylo.setbranchdata!","text":"setbranchdata!(::AbstractTree, branch, label, value)\nsetbranchdata!(::AbstractTree, branch, data)\n\nSet the branch data for a branch of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo","page":"Home","title":"Phylo","text":"","category":"section"},{"location":"#A-package-for-creating-and-manipulating-phylogenies","page":"Home","title":"A package for creating and manipulating phylogenies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Phylo is a Julia package that provides functionality for generating phylogenetic trees. It plays well with the Diversity package, i.e. to  calculate phylogenetic diversity. Both are currently under development, so please raise an issue if you find any  problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is currently less featured than the best phylogenetics packages in R or Python. Contributors  are very welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial / Quick start","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#to-do","page":"Tutorial / Quick start","title":"to do","text":"","category":"section"}]
}
