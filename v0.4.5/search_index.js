var documenterSearchIndex = {"docs":
[{"location":"api/#Phylo.API","page":"Phylo.API","title":"Phylo.API","text":"","category":"section"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"The Phylo.API submodule provides the API that must be extended for new AbstractTree, AbstractNode and AbstractBranch subtypes.","category":"page"},{"location":"api/#Usage","page":"Phylo.API","title":"Usage","text":"","category":"section"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"Providing additional code to extend the functionality of the system is simple:","category":"page"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"using Phylo\nimportall Phylo.API\n\ntype SimplestTree <: AbstractTree{Int, Int}\n    nodes::OrderedDict{Int, BinaryNode{Int}}\n    branches::Dict{Int, Branch{Int}}\nend\n\nfunction _addnode!(tree::SimplestTree, num)\n    _setnode!(tree, num, BinaryNode{Int}())\n    return num\nend","category":"page"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"creates a new SimplestTree type (a subtype of AbstractTree) and extends Phylo.API._addnode!() (and therefore the directly accessible addnode!() interface) to handle the SimplestTree subtype of AbstractTree. See docs here to see which Phylo.API functions have to be extended for any new subtype, and which have default implementations.","category":"page"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"","category":"page"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"Modules = [Phylo.API]\nPrivate = false","category":"page"},{"location":"api/#Phylo.API","page":"Phylo.API","title":"Phylo.API","text":"Phylo.API submodule\n\nThe Phylo.API submodule should be imported if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.\n\n\n\n\n\n","category":"module"},{"location":"api/#Phylo.API._addconnection!","page":"Phylo.API","title":"Phylo.API._addconnection!","text":"_addconnection!(tree::AbstractTree, node::AbstractNode, branch)\n\nAdd a connection to an unrooted node. Must be implemented for any unrooted AbstractNode subtype unless this happens when a branch is added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._addinbound!","page":"Phylo.API","title":"Phylo.API._addinbound!","text":"_addinbound!(tree::AbstractTree, node::AbstractNode, inbound)\n\nAdds a branch to the input of a rooted node. Must be implemented for any rooted AbstractNode subtype unless this happens when a branch is created.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._addoutbound!","page":"Phylo.API","title":"Phylo.API._addoutbound!","text":"_addoutbound!(tree::AbstractTree, node::AbstractNode, branch)\n\nAdd an outbound branch to a rooted node. Must be implemented for any Rooted AbstractNode subtype unless this happens when a branch is created.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._branchdatatype","page":"Phylo.API","title":"Phylo.API._branchdatatype","text":"_branchdatatype(::Type{<:AbstractTree})\n\nReturns the type of the branch info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._branchdims","page":"Phylo.API","title":"Phylo.API._branchdims","text":"_branchdims(::Type{<:AbstractTree})\n\nReturns the dimensions of the branch lengths for the tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._clearrootheight!","page":"Phylo.API","title":"Phylo.API._clearrootheight!","text":"_clearrootheight!(::AbstractTree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._createbranch!","page":"Phylo.API","title":"Phylo.API._createbranch!","text":"_createbranch!(tree::AbstractTree, source, destination,\n               length, data)\n\nCreate a new branch and add it to a tree. Must be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._createnode!","page":"Phylo.API","title":"Phylo.API._createnode!","text":"_createnode!(tree::AbstractTree, nodename)\n\nMust be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._degree","page":"Phylo.API","title":"Phylo.API._degree","text":"_degree(tree::AbstractTree, node::AbstractNode)\n\nDegree of node. Must be implemented for Unrooted nodes, otherwise can be inferred from indegree and outdegree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._deletebranch!","page":"Phylo.API","title":"Phylo.API._deletebranch!","text":"_deletebranch!(tree::AbstractTree, branch)\n\nDelete a branch, reoving it from a tree. Must be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._deletenode!","page":"Phylo.API","title":"Phylo.API._deletenode!","text":"_deletenode!(tree::AbstractTree, nodename)\n\nMust be implemented for any AbstractTree subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._dst","page":"Phylo.API","title":"Phylo.API._dst","text":"_dst(branch::AbstractBranch)\n\nReturn destination node for a branch. Must be implemented for any rooted AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranch","page":"Phylo.API","title":"Phylo.API._getbranch","text":"_getbranch(::AbstractTree, id)\n\nReturns the branch or name associated with id (which could be a name, a branch or a pair) from a tree. Must be implemented for any PreferBranchObjects tree and branch label type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranches","page":"Phylo.API","title":"Phylo.API._getbranches","text":"_getbranches(tree::AbstractTree)\n\nReturns a vector of branches for a OneTree tree. Either _getbranches() or _getbranchnames() must be implemented for any OneTree tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranchname","page":"Phylo.API","title":"Phylo.API._getbranchname","text":"_getbranchname(::AbstractTree, id)\n\nReturns the name of a branch associated with id (which could be a name, a branch or a pair) from a tree. Must be implemented for PreferBranchObjects tree types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getbranchnames","page":"Phylo.API","title":"Phylo.API._getbranchnames","text":"_getbranchnames(tree::AbstractTree)\n\nReturns a vector of branch names for a OneTree tree. Either _getbranches() or _getbranchnames() must be implemented for any OneTree tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getchildren","page":"Phylo.API","title":"Phylo.API._getchildren","text":"_getchildren(tree::AbstractTree, node)\n_getchildren(tree::AbstractTree, nodename)\n\nReturn the child node(s) for this node. May be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getconnections","page":"Phylo.API","title":"Phylo.API._getconnections","text":"_getconnections(tree::AbstractTree, node::AbstractNode)\n\nReturns all of the connections of a node. Must be implemented for any unrooted AbstractNode subtype, can be inferred from _getinbound and _getoutbounds for a rooted node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getheight-Tuple{AbstractTree,Any}","page":"Phylo.API","title":"Phylo.API._getheight","text":"_getheight(tree::AbstractTree, nodename)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._getinbound","page":"Phylo.API","title":"Phylo.API._getinbound","text":"_getinbound(tree::AbstractTree, node::AbstractNode)\n\nGet the inbound connection. Must be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getleafnames","page":"Phylo.API","title":"Phylo.API._getleafnames","text":"_getleafnames(::AbstractTree)\n\nReturns the leaf names of a tree. May be implemented for any tree type (otherwise determined from _getnodenames() and _isleaf() functions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getleaves","page":"Phylo.API","title":"Phylo.API._getleaves","text":"_getleaves(::AbstractTree)\n\nReturns the leaves (tips) of a single tree. May be implemented for any OneTree type (otherwise determined from _getnodes() and _isleaf() functions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getlength","page":"Phylo.API","title":"Phylo.API._getlength","text":"_getlength\n\nReturn length of a branch. May be implemented for any AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnode","page":"Phylo.API","title":"Phylo.API._getnode","text":"_getnode(::AbstractTree, id)\n\nReturns the node or name associated with id (which could be a name, a node or a pair) from a tree. Must be implemented for any PreferNodeObjects tree and node label type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnodenames","page":"Phylo.API","title":"Phylo.API._getnodenames","text":"_getnodenames(tree::AbstractTree{OneTree})\n\nReturns a vector of node names for a OneTree tree. Can be implemented for any OneTree tree type, especially PreferNodeObjects trees.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getnodes","page":"Phylo.API","title":"Phylo.API._getnodes","text":"_getnodes(tree::AbstractTree{OneTree})\n\nReturns a vector of nodes for a OneTree tree. Either _getnodes() must be implemented for any OneTree tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getoutbounds","page":"Phylo.API","title":"Phylo.API._getoutbounds","text":"_getoutbounds(tree::AbstractTree, node::AbstractNode)\n\nReturns the outbound connections of a rooted node. Must be implemented for any rooted AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getparent","page":"Phylo.API","title":"Phylo.API._getparent","text":"_getparent(tree::AbstractTree, node)\n\nReturn the parent node for this node. Can be implemented for Rooted node types.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getroot","page":"Phylo.API","title":"Phylo.API._getroot","text":"_getroot(::AbstractTree)\n\nReturns the unique root of a rooted tree. May be implemented for any OneTree type (otherwise determined from _getroots()).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getrootheight","page":"Phylo.API","title":"Phylo.API._getrootheight","text":"_getrootheight(::AbstractTree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._getroots-Tuple{AbstractTree{OneTree,var\"#s34\",NL,N,B} where B<:Phylo.AbstractBranch{var\"#s34\",NL} where N<:Phylo.AbstractNode{var\"#s34\",NL} where NL where var\"#s34\"<:Phylo.Rooted}","page":"Phylo.API","title":"Phylo.API._getroots","text":"_getroots(::AbstractTree)\n\nReturns the root(s) of a tree. May be implemented for any OneTree type (otherwise determined from _getnodes() and _isroot() functions).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._gettree","page":"Phylo.API","title":"Phylo.API._gettree","text":"_gettree(::Pair{Label, AbstractTree})\n_gettree(::AbstractTree, id)\n\nReturns a tree - either itself if it is a single tree, or the single tree in a set with label id. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreeinfo","page":"Phylo.API","title":"Phylo.API._gettreeinfo","text":"_gettreeinfo(tree::AbstractTree)\n_gettreeinfo(tree::AbstractTree, treename)\n\nReturns the info data associated with the tree(s).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreename","page":"Phylo.API","title":"Phylo.API._gettreename","text":"_gettreename(::AbstractTree)\n\nReturns the name for a single tree. Should be implemented for any OneTree type where they have names.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettreenames","page":"Phylo.API","title":"Phylo.API._gettreenames","text":"_gettreenames(::AbstractTree)\n\nReturns the names for the trees. Can be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._gettrees","page":"Phylo.API","title":"Phylo.API._gettrees","text":"_gettrees(::AbstractTree)\n\nReturns the trees in an object. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasbranch","page":"Phylo.API","title":"Phylo.API._hasbranch","text":"_hasbranch(tree::AbstractTree, node[name])\n\nDoes the tree contain this branch? Must be implemented for any PreferBranchObjects tree type with a branch label.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasheight-Tuple{AbstractTree,Any}","page":"Phylo.API","title":"Phylo.API._hasheight","text":"_hasheight(tree::AbstractTree, nodename)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._hasinbound","page":"Phylo.API","title":"Phylo.API._hasinbound","text":"_hasinbound(tree::AbstractTree, node::AbstractNode)\n\nMust be implemented for any AbstractNode subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasinboundspace","page":"Phylo.API","title":"Phylo.API._hasinboundspace","text":"_hasinboundspace(tree::AbstractTree, node::AbstractNode)\n\nIs there space for a new inbound connection on a node?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasnode","page":"Phylo.API","title":"Phylo.API._hasnode","text":"_hasnode(tree::AbstractTree, node[name])\n\nDoes the tree contain this node? Must be implemented for any PreferNodeObjects tree type with a node label.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasoutboundspace","page":"Phylo.API","title":"Phylo.API._hasoutboundspace","text":"_hasoutboundspace(tree::AbstractTree, node::AbstractNode)\n\nIs there space for a new outbound connection on a node? Must be implemented if a node has a limit on the number of outbound connections (eg for a binary tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._hasrootheight-Tuple{AbstractTree}","page":"Phylo.API","title":"Phylo.API._hasrootheight","text":"_hasrootheight(::AbstractTree)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._indegree","page":"Phylo.API","title":"Phylo.API._indegree","text":"_indegree(tree::AbstractTree, node)\n\nIn degree of node. Can be implemented for rooted nodes, otherwise inferred from _hasinbound.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isinternal","page":"Phylo.API","title":"Phylo.API._isinternal","text":"_isinternal(tree::AbstractTree, node)\n\nIs the node internal to the tree?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isleaf","page":"Phylo.API","title":"Phylo.API._isleaf","text":"_isleaf(tree::AbstractTree, node)\n\nIs the node a leaf? Does not need to be implemented for any node type – inferred from _outdegree or _degree - unless tree knows which nodes are leaves and not nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isroot","page":"Phylo.API","title":"Phylo.API._isroot","text":"_isroot(tree::AbstractTree, node)\n\nIs the node a root node of the tree?\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._isunattached-Tuple{AbstractTree,Any}","page":"Phylo.API","title":"Phylo.API._isunattached","text":"_isunattached(tree::AbstractTree, node)\n\nDoes the node currently form its own (sub)tree?\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._leafinfotype","page":"Phylo.API","title":"Phylo.API._leafinfotype","text":"_leafinfotype(::Type{<:AbstractTree})\n\nReturns the type of the leaf info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._nbranches-Tuple{AbstractTree{OneTree,RT,NL,N,B} where B<:Phylo.AbstractBranch{RT,NL} where N<:Phylo.AbstractNode{RT,NL} where NL where RT<:Phylo.Rootedness}","page":"Phylo.API","title":"Phylo.API._nbranches","text":"_nbranches(::AbstractTree)\n\nReturns the number of branches in a single tree. May be implemented for any OneTree tree type (otherwise infers from _getbranches()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._newbranchlabel","page":"Phylo.API","title":"Phylo.API._newbranchlabel","text":"_newbranchlabel(tree::AbstractTree)\n\nReturns a new unique branch name for a tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._newnodelabel","page":"Phylo.API","title":"Phylo.API._newnodelabel","text":"_newnodelabel(tree::AbstractTree)\n\nReturns a new unique node name for a tree.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._nleaves-Tuple{AbstractTree}","page":"Phylo.API","title":"Phylo.API._nleaves","text":"_nleaves(::AbstractTree)\n\nReturns the number of leaves (tips) in a tree. May be implemented for any tree type (otherwise determined from the _getleafnames() function).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._nnodes-Tuple{AbstractTree{OneTree,RT,NL,N,B} where B<:Phylo.AbstractBranch{RT,NL} where N<:Phylo.AbstractNode{RT,NL} where NL where RT<:Phylo.Rootedness}","page":"Phylo.API","title":"Phylo.API._nnodes","text":"_nnodes(::AbstractTree)\n\nReturns the number of nodes (internal nodes and leaves) in a single tree. May be implemented for any OneTree tree type (otherwise infers from _getnodes()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._nodedatatype","page":"Phylo.API","title":"Phylo.API._nodedatatype","text":"_nodedatatype(::Type{<:AbstractTree})\n\nReturns the type of the node info data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._nroots","page":"Phylo.API","title":"Phylo.API._nroots","text":"_nroots(::AbstractTree)\n\nReturns the number of roots (subtrees) in a OneTree tree. May be implemented for any ManyRoots type (otherwise infers from _getroots()).\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._ntrees","page":"Phylo.API","title":"Phylo.API._ntrees","text":"_ntrees(::AbstractTree)\n\nReturns the number of trees in an object. Must be implemented for any ManyTrees type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._outdegree","page":"Phylo.API","title":"Phylo.API._outdegree","text":"_outdegree(tree::AbstractTree, node::AbstractNode)\n\nOut degree of node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._preferbranchobjects","page":"Phylo.API","title":"Phylo.API._preferbranchobjects","text":"_preferbranchobjects(::Type{<:AbstractTree})\n_preferbranchobjects(::Type{<:AbstractBranch})\n\nDoes this tree or branch type prefer branches to be objects or names? Must be implemented for every branch type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._prefernodeobjects","page":"Phylo.API","title":"Phylo.API._prefernodeobjects","text":"_prefernodeobjects(::Type{<:AbstractTree})\n_prefernodeobjects(::Type{<:AbstractNode})\n\nDoes this tree or node type prefer nodes to be objects or names? Must be implemented for every node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeconnection!","page":"Phylo.API","title":"Phylo.API._removeconnection!","text":"_removeconnection!(tree::AbstractTree, node::AbstractNode, branch)\n\nRemove a connection from an unrooted node. Must be implemented for any Unrooted AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeinbound!","page":"Phylo.API","title":"Phylo.API._removeinbound!","text":"_removeinbound!(tree::AbstractTree, node::AbstractNode, inbound)\n\nRemoves a branch from the input of a rooted node. Must be implemented for any rooted AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._removeoutbound!","page":"Phylo.API","title":"Phylo.API._removeoutbound!","text":"_removeoutbound!(tree::AbstractTree, node::AbstractNode, branch)\n\nRemove an outbound branch from a rooted node. Must be implemented for any AbstractNode subtype unless this happens when a branch is deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._resetleaves!","page":"Phylo.API","title":"Phylo.API._resetleaves!","text":"_resetleaves!(::AbstractTree)\n\nFixes leaf naming after creation or deletion of nodes or branches. Must be implemented by tree types where this is handled separately.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._setheight!-Tuple{AbstractTree,Any,Any}","page":"Phylo.API","title":"Phylo.API._setheight!","text":"_setheight!(::AbstractTree, nodename, value)\n\n\n\n\n\n","category":"method"},{"location":"api/#Phylo.API._setrootheight!","page":"Phylo.API","title":"Phylo.API._setrootheight!","text":"_setrootheight!(::AbstractTree, value)\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._src","page":"Phylo.API","title":"Phylo.API._src","text":"_src(branch::AbstractBranch)\n\nReturn source node for a branch. Must be implemented for any rooted AbstractBranch subtype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._traversal","page":"Phylo.API","title":"Phylo.API._traversal","text":"_traversal(tree::AbstractTree, order::TraversalOrder, todo, sofar)\n\nReturn an iterable object containing nodes in given order - preorder, inorder, postorder or breadthfirst\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._treenametype","page":"Phylo.API","title":"Phylo.API._treenametype","text":"_treenametype(::Type{AbstractTree})\n\nReturns the label type for a tree type. Must be implemented for any tree type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phylo.API._validate!","page":"Phylo.API","title":"Phylo.API._validate!","text":"_validate!(::AbstractTree)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Phylo.API","title":"Phylo.API","text":"","category":"page"},{"location":"#Phylo","page":"Phylo","title":"Phylo","text":"","category":"section"},{"location":"","page":"Phylo","title":"Phylo","text":"Package for creating and manipulating phylogenies","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"Phylo is a Julia package that provides  functionality for generating phylogenetic trees to feed into our  Diversity package to calculate phylogenetic  diversity (currently on master,  but not released). Both are currently under development, so please  raise an issue if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from Distributions. For instance, to construct a sampler for 5 tip non-ultrametric  trees, and then generate one or two random tree of that type:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> using Phylo\n\njulia> nu = Nonultrametric(5);\n\njulia> tree = rand(nu)\nRootedTree with 5 tips, 9 nodes and 8 branches.\nLeaf names are tip 3, tip 5, tip 2, tip 4 and tip 1\n\njulia> trees = rand(nu, [\"Tree 1\", \"Tree 2\"])\nTreeSet with 2 trees, each with 5 tips.\nTree names are Tree 2 and Tree 1\n\nTree 1: RootedTree with 5 tips, 9 nodes and 8 branches.\nLeaf names are tip 5, tip 3, tip 4, tip 2 and tip 1\n\nTree 2: RootedTree with 5 tips, 9 nodes and 8 branches.\nLeaf names are tip 3, tip 5, tip 1, tip 2 and tip 4","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"The code also provides iterators, and filtered iterators over the branches, nodes, branchnames and nodenames of a tree:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> collect(nodeiter(tree))\n9-element Vector{LinkNode{OneRoot, String, Dict{String, Any}, LinkBranch{OneRoot, String, Dict{String, Any}, Float64}}}:\n LinkNode tip 1, a tip of the tree with an incoming connection (branch 16).\n\n LinkNode tip 2, a tip of the tree with an incoming connection (branch 10).\n\n LinkNode tip 3, a tip of the tree with an incoming connection (branch 11).\n\n LinkNode tip 4, a tip of the tree with an incoming connection (branch 14).\n\n LinkNode tip 5, a tip of the tree with an incoming connection (branch 9).\n\n LinkNode Node 6, an internal node with 1 inbound and 2 outbound connections (branches 12 and 9, 10)\n\n LinkNode Node 7, an internal node with 1 inbound and 2 outbound connections (branches 13 and 11, 12)\n\n LinkNode Node 8, an internal node with 1 inbound and 2 outbound connections (branches 15 and 13, 14)\n\n LinkNode Node 9, a root node with 2 outbound connections (branches 15, 16)\n\njulia> collect(nodenamefilter(isroot, tree))\n1-element Vector{String}:\n \"Node 9\"","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"TreeSets are iterators themselves","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> collect(trees)\n\n2-element Vector{RootedTree}:\n RootedTree with 5 tips, 9 nodes and 8 branches.\nLeaf names are tip 3, tip 5, tip 1, tip 2 and tip 4\n\n RootedTree with 5 tips, 9 nodes and 8 branches.\nLeaf names are tip 3, tip 5, tip 1, tip 2 and tip 4","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"The current main purpose of this package is to provide a framework for phylogenetics to use in our [Diversity][diversity-url] package, and they will both be adapted as appropriate until both are functioning as required (though they are currently working together reasonably successfully).","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"It can also read newick trees either from strings or files:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> using Phylo\n\njulia> simpletree = parsenewick(\"((,Tip:1.0)Internal,)Root;\")\nRootedTree with 3 tips, 5 nodes and 4 branches.\nLeaf names are Tip, Node 1 and Node 4\n\n\njulia> getbranches(simpletree)\nskipmissing(Union{Missing, LinkBranch{OneRoot, String, Dict{String, Any}, Float64}}[LinkBranch 1, from node Internal to node Tip (length 1.0).\n, LinkBranch 2, from node Internal to node Node 1.\n, LinkBranch 3, from node Root to node Internal.\n, LinkBranch 4, from node Root to node Node 4.\n])\n\njulia> tree = open(parsenewick, Phylo.path(\"H1N1.newick\"))\nRootedTree with 507 tips, 1013 nodes and 1012 branches.\nLeaf names are 227, 294, 295, 110, 390, ... [501 omitted] ... and 418","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"And it can read nexus trees from files too:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"jjulia> ts = open(parsenexus, Phylo.path(\"H1N1.trees\"))\n[ Info: Created a tree called \"TREE1\"\n[ Info: Created a tree called \"TREE2\"\nTreeSet with 2 trees, each with 507 tips.\nTree names are TREE2 and TREE1\n\nTREE1: RootedTree with 507 tips, 1013 nodes and 1012 branches.\nLeaf names are H1N1_A_BRAZIL_11_1978, H1N1_A_TAHITI_8_1998, H1N1_A_TAIWAN_1_1986, H1N1_A_BAYERN_7_1995, H1N1_A_ENGLAND_45_1998, ... [501 omitted] ... and H1N1_A_PUERTORICO_8_1934\n\nTREE2: RootedTree with 507 tips, 1013 nodes and 1012 branches.\nLeaf names are H1N1_A_BRAZIL_11_1978, H1N1_A_TAHITI_8_1998, H1N1_A_TAIWAN_1_1986, H1N1_A_BAYERN_7_1995, H1N1_A_ENGLAND_45_1998, ... [501 omitted] ... and H1N1_A_PUERTORICO_8_1934\n\njulia> ts[\"TREE1\"]\nRootedTree with 507 tips, 1013 nodes and 1012 branches.\nLeaf names are H1N1_A_BRAZIL_11_1978, H1N1_A_TAHITI_8_1998, H1N1_A_TAIWAN_1_1986, H1N1_A_BAYERN_7_1995, H1N1_A_ENGLAND_45_1998, ... [501 omitted] ... and H1N1_A_PUERTORICO_8_1934\n\njulia> gettreeinfo(ts)\nDict{String, Dict{String, Any}} with 2 entries:\n  \"TREE2\" => Dict(\"lnP\"=>-1.0)\n  \"TREE1\" => Dict(\"lnP\"=>1.0)","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"And while we wait for me (or kind contributors!) to fill out the other extensive functionality that many phylogenetics packages have in other languages, the other important feature that it offers is a fully(?)-functional interface to R, allowing any existing R library functions to be carried out on julia trees, and trees to be read from disk and written using R helper functions. Naturally the medium-term plan is to fill in as many of these gaps as possible in Julia, and as a result this R interface is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, if you want to use the R interface you need to do it manually, as below:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> using RCall\n\njulia> include(Phylo.path(\"rcall.jl\", dir = \"src\"));\n\nR> library(ape)","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"You can then translate back and forth using rcopy on R phylo objects, and RObject constructors on julia NamedTree types to keep them in Julia or @rput to move the object into R:","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"julia> rt = rcall(:rtree, 10)\nRCall.RObject{RCall.VecSxp}\n\nPhylogenetic tree with 10 tips and 9 internal nodes.\n\nTip labels:\n\tt10, t8, t1, t2, t6, t5, ...\n\nRooted; includes branch lengths.\n\njulia> jt = rcopy(NamedTree, rt)\nNamedTree with 10 tips, 19 nodes and 18 branches.\nLeaf names are t8, t3, t7, t9, t6, ... [4 omitted] ... and t1\n\njulia> rjt = RObject(jt); # manually translate it back to R\n\nR> if (all.equal($rjt, $rt)) \"no damage in translation\"\n[1] \"no damage in translation\"\n\njulia> @rput rt; # Or use macros to pass R object back to R\n\njulia> @rput jt; # And automatically translate jt back to R\n\nR> jt\n\nPhylogenetic tree with 10 tips and 9 internal nodes.\n\nTip labels:\n\tt10, t8, t1, t2, t6, t5, ...\n\nRooted; includes branch lengths.\n\nR> if (all.equal(rt, jt)) \"no damage in translation\"\n[1] \"no damage in translation\"","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"","category":"page"},{"location":"","page":"Phylo","title":"Phylo","text":"Modules = [Phylo]\nPrivate = false","category":"page"},{"location":"#Phylo.Phylo","page":"Phylo","title":"Phylo.Phylo","text":"Phylo package\n\nThe Phylo package provides some simple phylogenetics types (e.g. NamedTree) to interface to the Diversity package for measuring phylogenetic diversity. It also provides an interface to R for copying trees to and from that language and can read newick and nexus tree files (including TreeSets that contain multiple trees).\n\nFinally it also provides a standard abstract interface to phylogenetic trees, by defining AbstractNode, AbstractBranch and AbstractTree supertypes, and methods to interface to them. It also provides (through the Phylo.API submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages.\n\n\n\n\n\n","category":"module"},{"location":"#Phylo.BinaryNode","page":"Phylo","title":"Phylo.BinaryNode","text":"BinaryNode{B}(AbstractVector{B}, AbstractVector{B}) <: AbstractNode\n\nA node of strict binary phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.BinaryTree","page":"Phylo","title":"Phylo.BinaryTree","text":"BinaryTree\n\nBinary phylogenetic tree object with known leaves and per node data\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.Branch","page":"Phylo","title":"Phylo.Branch","text":"Branch\n\nA branch connecting two AbstractNodes of a phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.BrownianTrait","page":"Phylo","title":"Phylo.BrownianTrait","text":"BrownianTrait{T <: AbstractTree, N <: Number}\n\nA continuous trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(). The trait to be evolved can be any continuous numeric type, including Unitful types for instance, and in the simplest case is determined by the third argument to the constructor start:\n\nfunction BrownianTrait(tree::AbstractTree, trait::String, start::Number = 0.0;                        σ² = missing, σ = missing, f::Function = identity)\n\nNote that when Unitful is being used, either here or in branch lengths, σ/σ² keyword argument units must be appropriate. The final keyword argument, f, is a function to transform the evolved gaussian trait into its true value. By default this is the identity function, but can, for instance, be abs to force a positive value on the trait, or more complex functions as required, such as a transformation to turn a continuous variable into a discrete trait\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.DiscreteTrait","page":"Phylo","title":"Phylo.DiscreteTrait","text":"DiscreteTrait{T <: AbstractTree, E <: Enum}\n\nA discrete trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(dt). The trait to be evolved must be an Enum (generally created using @enum), and is the second argument to the constructor:\n\nfunction DiscreteTrait(tree::AbstractTree, ttype::Type{<:Enum},                        transition_matrix::AbstractMatrix{Float64},                        trait::String = \"ttype\")\n\nThe transition matrix holds transition rates from row to column (so row sums must be zero), and the transition probabilities in a branch are calculated as exp(transition_matrix .* branch_length).\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.NamedBinaryTree","page":"Phylo","title":"Phylo.NamedBinaryTree","text":"NamedBinaryTree\n\nBinary phylogenetic tree object with known leaves\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.NamedTree","page":"Phylo","title":"Phylo.NamedTree","text":"NamedPolytomousTree\n\nPolytomous phylogenetic tree object with known leaves\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.Node","page":"Phylo","title":"Phylo.Node","text":"Node{RT, NL, T}(AbstractVector{T}, AbstractVector{T}) <: AbstractNode\n\nA node of potentially polytomous phylogenetic tree\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.Nonultrametric","page":"Phylo","title":"Phylo.Nonultrametric","text":"Nonultrametric{T <: AbstractTree,\n               SAMP <: Sampleable}(n::Int,\n                                   sampleable::SAMP = Exponential())\nNonultrametric{T <: AbstractTree,\n               SAMP <: Sampleable}(tiplabels::Vector{String},\n                                   sampleable::SAMP = Exponential())\n\nThe sampler for non-ultrametric phylogenetic trees of size n or with tip labels tiplabels. Generate random trees by calling rand().\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.PolytomousTree","page":"Phylo","title":"Phylo.PolytomousTree","text":"PolytomousTree\n\nPhylogenetic tree object with polytomous branching, and known leaves and per node data\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.SymmetricDiscreteTrait","page":"Phylo","title":"Phylo.SymmetricDiscreteTrait","text":"SymmetricDiscreteTrait{T <: AbstractTree, E <: Enum}\n\nThe simplest possible discrete trait evolved on a phylogenetic tree. This is a Sampleable type, so a random trait can be created using rand(sdt). The trait to be evolved must be an Enum (generally created using @enum), and is the second argument to the constructor:\n\nfunction DiscreteTrait(tree::AbstractTree, ttype::Type{<:Enum},                        transition_rate::Number,                        trait::String = \"ttype\")\n\nThe transition matrix holds transition rates from row to column (so row sums must be zero), and the transition probabilities in a branch are calculated as exp(transition_matrix .* branch_length).\n\n\n\n\n\n","category":"type"},{"location":"#Phylo.Ultrametric","page":"Phylo","title":"Phylo.Ultrametric","text":"Ultrametric{T <: AbstractTree,\n            SAMP <: Sampleable,\n            LenUnits <: Number}(n::Int,\n                                sampleable::SAMP = Exponential())\nUltrametric{T <: AbstractTree,\n            SAMP <: Sampleable,\n            LenUnits <: Number}(tiplabels::Vector{String},\n                                sampleable::SAMP = Exponential())\n\nThe sampler for ultrametric phylogenetic trees of size n or with tip labels tiplabels. Generate random trees by calling rand().\n\n\n\n\n\n","category":"type"},{"location":"#LightGraphs.dst","page":"Phylo","title":"LightGraphs.dst","text":"dst(tree::AbstractTree, branch)\n\nReturn the destination node for this branch.\n\n\n\n\n\n","category":"function"},{"location":"#LightGraphs.indegree","page":"Phylo","title":"LightGraphs.indegree","text":"indegree(tree::AbstractTree, node)\n\nReturn in degree of node.\n\n\n\n\n\n","category":"function"},{"location":"#LightGraphs.outdegree","page":"Phylo","title":"LightGraphs.outdegree","text":"outdegree(tree::AbstractTree, node)\n\nReturn out degree of node.\n\n\n\n\n\n","category":"function"},{"location":"#LightGraphs.src","page":"Phylo","title":"LightGraphs.src","text":"src(tree::AbstractTree, branch)\n\nReturn the source node for this branch.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.branchdatatype-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.branchdatatype","text":"branchdatatype(::Type{<: AbstractTree})\n\nretrieve the branch info type of a tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchdims-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.branchdims","text":"branchdims(::Type{<: AbstractTree})\n\nretrieve the dimensions of the branch lengths for the tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchfilter-Union{Tuple{T}, Tuple{Function,T}} where T<:AbstractTree","page":"Phylo","title":"Phylo.branchfilter","text":"branchfilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the branches of any tree, where the AbstractBranch is filtered by the function filterfn.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchfuture","page":"Phylo","title":"Phylo.branchfuture","text":"branchfuture(tree::AbstractTree, node)\n\nFind the branches between a node on a tree and its leaves\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.branchhistory","page":"Phylo","title":"Phylo.branchhistory","text":"branchhistory(tree::AbstractTree, node)\n\nFind the branch route between a node on a tree and its root\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.branchiter-Tuple{T} where T<:AbstractTree","page":"Phylo","title":"Phylo.branchiter","text":"branchiter(tree::AbstractTree)\n\nReturns an iterator over the branches of any tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchnamefilter-Union{Tuple{T}, Tuple{Function,T}} where T<:AbstractTree","page":"Phylo","title":"Phylo.branchnamefilter","text":"branchnamefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the names of the branches of any tree, where the AbstractBranch is filtered by the function filterfn.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchnameiter-Tuple{T} where T<:AbstractTree","page":"Phylo","title":"Phylo.branchnameiter","text":"branchnameiter(tree::AbstractTree)\n\nReturns an iterator over the names of branches of any tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchnametype-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.branchnametype","text":"branchnametype(::AbstractTree)\n\nReturns type of branch names from a branch type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.branchroute","page":"Phylo","title":"Phylo.branchroute","text":"branchroute(tree::AbstractTree, node1, node2)\n\nFind the branch route between two nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.branchtype-Union{Tuple{Type{T}}, Tuple{T}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{TT}} where T<:AbstractTree{TT,RT,NL,N,B} where B<:Phylo.AbstractBranch where N where NL where RT where TT","page":"Phylo","title":"Phylo.branchtype","text":"branchtype(::Type{AbstractTree})\n\nReturns type of branches from a tree type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.createbranch!","page":"Phylo","title":"Phylo.createbranch!","text":"createbranch!(tree::AbstractTree, src, dst[, len::Number];\n              data)\n\nAdd a branch from src to dst on tree with optional length and data. source and destination can be either nodes or nodenames.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.createnode!-Union{Tuple{AbstractTree{OneTree,RT,NL,N,B}}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{AbstractTree{OneTree,RT,NL,N,B},Any}} where B where N where NL where RT","page":"Phylo","title":"Phylo.createnode!","text":"createnode!(tree::AbstractTree[, nodename]; data)\n\nCreate a node on a tree with optional node info.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.createnodes!","page":"Phylo","title":"Phylo.createnodes!","text":"createnodes!(tree::AbstractTree, count::Integer)\ncreatenodes!(tree::AbstractTree, nodenames)\ncreatenodes!(tree::AbstractTree, nodedict)\n\nAdd a number of nodes, a vector with given names, or a Dict with node names and associated node info to a tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.deletebranch!","page":"Phylo","title":"Phylo.deletebranch!","text":"deletebranch!(tree::AbstractTree, branch)\ndeletebranch!(tree::AbstractTree, src, dst)\n\nDelete the branch branch from tree, or branch connecting src node to dst node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.deletenode!","page":"Phylo","title":"Phylo.deletenode!","text":"deletenode!(tree::AbstractTree, node)\n\nDelete a node (or a name) from a tree\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.distance-Tuple{AbstractTree,Any,Any}","page":"Phylo","title":"Phylo.distance","text":"distance(tree::AbstractTree, node1, node2)\n\nDistance between two nodes on a tree\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.distances-Tuple{AbstractTree}","page":"Phylo","title":"Phylo.distances","text":"distances(tree::AbstractTree)\n\nPairwise distances between all leaf nodes on a tree\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.droptips!","page":"Phylo","title":"Phylo.droptips!","text":"droptips!(tree::AbstractTree{OneTree}, tips)\n\nFunction to drop tips from a phylogenetic tree tree, which are found in the vector of tips or tip names, tips.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getancestors","page":"Phylo","title":"Phylo.getancestors","text":"getancestors(tree::AbstractTree, node)\n\nReturn the name of all of the nodes that are ancestral to this node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getbranch","page":"Phylo","title":"Phylo.getbranch","text":"getbranch(tree::AbstractTree, branch)\ngetbranch(tree::AbstractTree, source, dest)\n\nReturns a branch from a tree by name or by source and destination node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getbranchdata","page":"Phylo","title":"Phylo.getbranchdata","text":"getbranchdata(::AbstractTree, label)\n\nretrieve the branch data for a leaf of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getbranches","page":"Phylo","title":"Phylo.getbranches","text":"getbranches(::AbstractTree)\n\nReturns the vector of branches of a single tree, or a Dict of vectors of branches for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getbranchname","page":"Phylo","title":"Phylo.getbranchname","text":"getbranchname(::AbstractTree, branch)\ngetbranchname(branch)\n\nReturns the branch name associated with a branch from a tree. For some branch types, it will be able to extract the branch name without reference to the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getbranchnames","page":"Phylo","title":"Phylo.getbranchnames","text":"getbranchnames(tree::AbstractTree)\n\nReturn a vector of branch names of a single tree, or a Dict of vectors of branch names for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getchildren","page":"Phylo","title":"Phylo.getchildren","text":"getchildren(tree::AbstractTree, node)\n\nReturn the [name(s) of] the child node(s) for this node [name].\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getdescendants","page":"Phylo","title":"Phylo.getdescendants","text":"getdescendants(tree::AbstractTree, node)\n\nReturn the names of all of the nodes that descend from this node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getheight","page":"Phylo","title":"Phylo.getheight","text":"getheight(tree::AbstractTree, node)\n\nReturn the height of the node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getinbound","page":"Phylo","title":"Phylo.getinbound","text":"getinbound(tree::AbstractTree, node)\n\nreturn the inbound branch to this node (returns name for node name, branch for node).\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getleafinfo","page":"Phylo","title":"Phylo.getleafinfo","text":"getleafinfo(::AbstractTree[, label])\n\nretrieve the leaf info for a leaf of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getleafnames","page":"Phylo","title":"Phylo.getleafnames","text":"getleafnames(::AbstractTree[, ::TraversalOrder])\n\nRetrieve the leaf names from the tree (in some specific order).\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getleaves","page":"Phylo","title":"Phylo.getleaves","text":"getleaves(::AbstractTree[, ::TraversalOrder])\n\nRetrieve the leaves from the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getlength","page":"Phylo","title":"Phylo.getlength","text":"getlength(tree::AbstractTree, branch)\n\nReturn the length of this branch.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getnode-Tuple{AbstractTree{OneTree,RT,NL,N,B} where B<:Phylo.AbstractBranch{RT,NL} where N<:Phylo.AbstractNode{RT,NL} where NL where RT<:Phylo.Rootedness,Any}","page":"Phylo","title":"Phylo.getnode","text":"getnode(tree::AbstractTree, nodename)\n\nReturns a node from a tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.getnodedata","page":"Phylo","title":"Phylo.getnodedata","text":"getnodedata(::AbstractTree, node)\n\nretrieve the node data for a node of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getnodename","page":"Phylo","title":"Phylo.getnodename","text":"getnodename(::AbstractTree, node)\n\nReturns the node name associated with a node from a tree. For some node types, it will be able to extract the node name without reference to the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getnodenames","page":"Phylo","title":"Phylo.getnodenames","text":"getnodenames(::AbstractTree[, ::TraversalOrder])\n\nReturn a vector of node names of a single tree (identified by id for a ManyTrees tree), or a Dict of vectors of node names for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getnodes","page":"Phylo","title":"Phylo.getnodes","text":"getnodes(::AbstractTree[, ::TraversalOrder])\n\nReturns the vector of nodes of a single tree, or a Dict of vectors of nodes for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getoutbounds","page":"Phylo","title":"Phylo.getoutbounds","text":"getoutbounds(tree::AbstractTree, nodename)\n\nReturn the names of the outbound branches from this node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getparent","page":"Phylo","title":"Phylo.getparent","text":"getparent(tree::AbstractTree, node)\n\nReturn [the name of] the parent node for this node [name]. Second method may not be implemented for some node types.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getroot","page":"Phylo","title":"Phylo.getroot","text":"getroot(::AbstractTree)\n\nReturns the root of a single tree (must be only one tree for a ManyTrees tree).\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.getrootheight-Tuple{AbstractTree{OneTree,var\"#s55\",NL,N,B} where B<:Phylo.AbstractBranch{var\"#s55\",NL} where N<:Phylo.AbstractNode{var\"#s55\",NL} where NL where var\"#s55\"<:Phylo.Rooted}","page":"Phylo","title":"Phylo.getrootheight","text":"getrootheight(tree::AbstractTree)\n\nGet the tree's root height.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.getroots","page":"Phylo","title":"Phylo.getroots","text":"getroots(::AbstractTree)\ngetroots(::AbstractTree, id)\n\nReturns a vector containing the root(s) of a single (OneTree) tree or a set of (ManyTrees) trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.gettreeinfo","page":"Phylo","title":"Phylo.gettreeinfo","text":"gettreeinfo(tree::AbstractTree)\ngettreeinfo(tree::AbstractTree, treename)\n\nReturns the info data associated with the tree(s).\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.gettreename-Tuple{AbstractTree{OneTree,RT,NL,N,B} where B<:Phylo.AbstractBranch{RT,NL} where N<:Phylo.AbstractNode{RT,NL} where NL where RT<:Phylo.Rootedness}","page":"Phylo","title":"Phylo.gettreename","text":"gettreename(tree::AbstractTree)\n\nReturns the name of the single tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.gettreenames","page":"Phylo","title":"Phylo.gettreenames","text":"gettreenames(tree::AbstractTree)\n\nReturns the names of the trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.gettrees-Tuple{AbstractTree}","page":"Phylo","title":"Phylo.gettrees","text":"gettrees(tree::AbstractTree)\n\nReturns an iterable of trees.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.hasbranch","page":"Phylo","title":"Phylo.hasbranch","text":"hasbranch(tree::AbstractTree, branch)\nhasbranch(tree::AbstractTree, source, dest)\n\nDoes tree have a branch branch or a branch from source to dest?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.hasheight","page":"Phylo","title":"Phylo.hasheight","text":"hasheight(tree::AbstractTree, node)\n\nDoes the node have a height defined?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.hasinbound","page":"Phylo","title":"Phylo.hasinbound","text":"hasinbound(tree::AbstractTree, node)\n\nDoes the node have an inbound connection?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.hasinboundspace","page":"Phylo","title":"Phylo.hasinboundspace","text":"hasinboundspace(tree::AbstractTree, node)\n\nDoes the node have space for an inbound connection?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.hasnode-Tuple{AbstractTree{OneTree,RT,NL,N,B} where B<:Phylo.AbstractBranch{RT,NL} where N<:Phylo.AbstractNode{RT,NL} where NL where RT<:Phylo.Rootedness,Any}","page":"Phylo","title":"Phylo.hasnode","text":"hasnode(tree::AbstractTree, node)\n\nReturns whether a tree has a given node (or node name) or not.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.hasoutboundspace","page":"Phylo","title":"Phylo.hasoutboundspace","text":"hasoutboundspace(tree::AbstractTree, node)\n\nDoes the node have space for an[other] outbound connection?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.hasrootheight","page":"Phylo","title":"Phylo.hasrootheight","text":"hasrootheight(tree::AbstractTree)\n\nDoes the tree have an explicit root height\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.heightstoroot-Tuple{AbstractTree}","page":"Phylo","title":"Phylo.heightstoroot","text":"heights(tree::AbstractTree)\n\nHeight of all of the leaves of the tree above the root\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.heighttoroot-Tuple{AbstractTree{OneTree,var\"#s55\",NL,N,B} where B<:Phylo.AbstractBranch{var\"#s55\",NL} where N<:Phylo.AbstractNode{var\"#s55\",NL} where NL where var\"#s55\"<:Phylo.Rooted,Any}","page":"Phylo","title":"Phylo.heighttoroot","text":"height(tree::AbstractTree, node)\n\nHeight of a node of the tree above the root\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.isinternal","page":"Phylo","title":"Phylo.isinternal","text":"isinternal(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) internal to the tree (neither root nor leaf)?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.isleaf","page":"Phylo","title":"Phylo.isleaf","text":"isleaf(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) a leaf of the tree?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.isroot","page":"Phylo","title":"Phylo.isroot","text":"isroot(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) a root of the tree?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.isunattached","page":"Phylo","title":"Phylo.isunattached","text":"isunattached(tree::AbstractTree, node)\n\nIs the node (referenced by name or node object) unattached (i.e. not connected to other nodes)?\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.keeptips!","page":"Phylo","title":"Phylo.keeptips!","text":"keeptips!(tree::AbstractTree{OneTree}, tips)\n\nFunction to keep only the tips in a phylogenetic tree, tree, that are found in the vector of tips or tip names, tips.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.leafinfotype-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.leafinfotype","text":"leafinfotype(::Type{<: AbstractTree})\n\nretrieve the leaf info type of a tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nbranches","page":"Phylo","title":"Phylo.nbranches","text":"nbranches(::AbstractTree)\n\nReturns the number of branches of a single tree, or a Dict of numbers of branches for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.nleaves-Tuple{AbstractTree}","page":"Phylo","title":"Phylo.nleaves","text":"nleaves(::AbstractTree)\n\nReturns the number of leaves (tips) in a tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nnodes","page":"Phylo","title":"Phylo.nnodes","text":"nnodes(::AbstractTree)\n\nReturns the number of nodes of a single tree, or a Dict of numbers of nodes for multiple trees.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.nodedatatype-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.nodedatatype","text":"nodedatatype(::Type{<: AbstractTree})\n\nretrieve the node info type of a tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nodefilter-Union{Tuple{T}, Tuple{Function,T}} where T<:AbstractTree","page":"Phylo","title":"Phylo.nodefilter","text":"nodefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the nodes of any tree, where the AbstractNode is filtered by the function filterfn.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nodefuture","page":"Phylo","title":"Phylo.nodefuture","text":"nodefuture(tree::AbstractTree, node)\n\nFind the nodes between a node on a tree and its leaves\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.nodehistory","page":"Phylo","title":"Phylo.nodehistory","text":"nodehistory(tree::AbstractTree, node)\n\nFind the node route between a node on a tree and its root\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.nodeiter-Tuple{T} where T<:AbstractTree","page":"Phylo","title":"Phylo.nodeiter","text":"nodeiter(tree::AbstractTree)\n\nReturns an iterator over the nodes of any tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nodenamefilter-Union{Tuple{T}, Tuple{Function,T}} where T<:AbstractTree","page":"Phylo","title":"Phylo.nodenamefilter","text":"nodenamefilter(filterfn::Function, tree::AbstractTree)\n\nReturns an iterator over the nodenames of any tree, where the AbstractNode itself is filtered by the function filterfn.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nodenameiter-Tuple{T} where T<:AbstractTree","page":"Phylo","title":"Phylo.nodenameiter","text":"nodenameiter(tree::AbstractTree)\n\nReturns an iterator over the names of the nodes of any tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nodenametype-Union{Tuple{Type{T}}, Tuple{T}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{TT}} where T<:AbstractTree{TT,RT,NL,N,B} where B where N where NL where RT where TT","page":"Phylo","title":"Phylo.nodenametype","text":"nodenametype(::Type{AbstractTree})\nnodenametype(::Type{AbstractNode})\nnodenametype(::Type{AbstractBranch})\n\nReturns type of node names from a tree type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.noderoute","page":"Phylo","title":"Phylo.noderoute","text":"noderoute(tree::AbstractTree, node1, node2)\n\nFind the node route between two nodes on a tree\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.nodetype-Union{Tuple{Type{T}}, Tuple{T}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{TT}} where T<:AbstractTree{TT,RT,NL,N,B} where B where N<:Phylo.AbstractNode where NL where RT where TT","page":"Phylo","title":"Phylo.nodetype","text":"nodetype(::Type{AbstractTree})\n\nReturns type of nodes from a tree type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.nroots","page":"Phylo","title":"Phylo.nroots","text":"nroots(::AbstractTree)\n\nReturns the number of roots in a tree. For OneTree types, Unrooted trees will return 0, OneRoot trees should return 1, and manyroots tree (ones with multiple subtrees) will return the number of subtrees. ManyTrees types will return a Dict of counts of the number of roots for each tree in the set.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.ntrees-Tuple{AbstractTree}","page":"Phylo","title":"Phylo.ntrees","text":"ntrees(tree::AbstractTree)\n\nReturns the number of trees in a tree object, 1 for a OneTree tree type, and the count of trees for a ManyTrees type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.roottype-Union{Tuple{Type{T}}, Tuple{T}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{TT}} where T<:AbstractTree{TT,RT,NL,N,B} where B where N where NL where RT<:Phylo.Rootedness where TT","page":"Phylo","title":"Phylo.roottype","text":"roottype(::Type{AbstractTree})\nroottype(::Type{AbstractNode})\nroottype(::Type{AbstractBranch})\n\nReturns root type from a tree type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.setbranchdata!","page":"Phylo","title":"Phylo.setbranchdata!","text":"setbranchdata!(::AbstractTree, branch, label, value)\nsetbranchdata!(::AbstractTree, branch, data)\n\nSet the branch data for a branch of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.setheight!","page":"Phylo","title":"Phylo.setheight!","text":"setheight!(tree::AbstractTree, nodename, height)\n\nSet the height of the node.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.setleafinfo!-Tuple{AbstractTree,Any}","page":"Phylo","title":"Phylo.setleafinfo!","text":"setleafinfo!(::AbstractTree, table)\n\nSet the leaf info for the leaves of the tree.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.setnodedata!","page":"Phylo","title":"Phylo.setnodedata!","text":"setnodedata!(::AbstractTree, node, label, value)\nsetnodedata!(::AbstractTree, node, data)\n\nSet the node data for a node of the tree.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.setrootheight!","page":"Phylo","title":"Phylo.setrootheight!","text":"setrootheight!(tree::AbstractTree, height)\n\nSet the tree's root height.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.traversal","page":"Phylo","title":"Phylo.traversal","text":"traversal(::AbstractTree, ::TraversalOrder)\ntraversal(::AbstractTree, ::TraversalOrder, init)\n\nReturn an iterable object for a tree containing nodes in given order - preorder, inorder, postorder or breadthfirst - optionally starting from init.\n\n\n\n\n\n","category":"function"},{"location":"#Phylo.treenametype-Tuple{Type{var\"#s34\"} where var\"#s34\"<:AbstractTree}","page":"Phylo","title":"Phylo.treenametype","text":"treenametype(::Type{AbstractTree})\n\nReturns the name type for a tree type.\n\n\n\n\n\n","category":"method"},{"location":"#Phylo.validate!-Union{Tuple{T}, Tuple{B}, Tuple{N}, Tuple{NL}, Tuple{RT}, Tuple{TT}} where T<:AbstractTree{TT,RT,NL,N,B} where B where N where NL where RT where TT","page":"Phylo","title":"Phylo.validate!","text":"validate!(tree::AbstractTree)\n\nValidate the tree by making sure that it is connected up correctly.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Phylo","title":"Phylo","text":"","category":"page"}]
}
