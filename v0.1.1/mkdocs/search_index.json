{
    "docs": [
        {
            "location": "/", 
            "text": "Phylo\n\n\nPackage for creating and manipulating phylogenies\n\n\nPhylo\n is a \nJulia\n package that provides  functionality for generating phylogenetic trees to feed into our  [Diversity][diversity-url] package to calculate phylogenetic  diversity (currently on master, accessible via \nPkg.checkout()\n,  but not released). Both are currently under development, so please  [raise an issue][issues-url] if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from \nDistributions\n. For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:\n\n\njulia\n \nusing\n \nPhylo\n\n\n\njulia\n \nnu\n \n=\n \nNonultrametric\n(\n5\n);\n\n\n\njulia\n \nrand\n(\nnu\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n9\n \nnodes\n \nand\n \n8\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\ntip 1\n,\n \ntip 2\n,\n \ntip 3\n,\n \ntip 4\n,\n \ntip 5\n]\n\n\n\n\n\n\nThe main purpose of this package is to provide a framework for phylogenetics to use in our [Diversity][diversity-url] package, and they will \nboth\n be adapted as appropriate until both are functioning as required.\n\n\nHowever, the other important feature that it holds is to allow an interface to R, allowing any existing R functionality to be carried out on julia trees, and trees to be read from disk and written using R helper functions. This is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, for now, if you want to use the R interface you need to do it manually, as below:\n\n\njulia\n \nusing\n \nRCall\n\n\n\njulia\n \ninclude\n(\njoinpath\n(\nPkg\n.\ndir\n(\nPhylo\n),\n \nsrc\n,\n \nrcall.jl\n));\n\n\n\nR\n \nlibrary\n(\nape\n)\n\n\n\n\n\n\nYou can then translate back and forth using \nNamedTree\n contructors on R \nphylo\n objects, and \nRObject\n constructors on julia \nNamedTree\n types to keep them in Julia or \n@rput\n to move the object into R:\n\n\njulia\n \nrt\n \n=\n \nrcall\n(\n:\nrtree\n,\n \n10\n)\n\n\nRCall\n.\nRObject\n{\nRCall\n.\nVecSxp\n}\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\njulia\n \njt\n \n=\n \nNamedTree\n(\nrt\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n19\n \nnodes\n \nand\n \n18\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \nt3\n,\n \nt4\n,\n \nt7\n,\n \nt9\n]\n\n\n\njulia\n \n@rput\n \nrt\n;\n\n\n\njulia\n \n@rput\n \njt\n;\n \n# Automatically translates jt back to R\n\n\n\nR\n \njt\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\nR\n \nall\n.\nequal\n(\nrt\n,\n \njt\n)\n \n# check no damage in translations\n\n\n[\n1\n]\n \nTRUE\n\n\n\n\n\n\n[issues-url]: https://github.com/richardreeve/Phylo.jl/issues [diversity-url]: https://github.com/richardreeve/Diversity.jl/\n\n\n\n\nPhylo\n\n\n\n\n#\n\n\nPhylo\n \n \nModule\n.\n\n\nPhylo package\n\n\n\n\n\nThe \nPhylo\n package provides a standard abstract interface to phylogenetic trees, by defining \nAbstractNode\n, \nAbstractBranch\n and \nAbstractTree\n supertypes, and methods to interface to them. It also provides (through the \nPhylo.API\n submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryNode\n \n \nType\n.\n\n\nBinaryNode{T}(AbstractVector{T}, AbstractVector{T}) \n: AbstractNode\n\n\n\n\n\nA node of strict binary phylogenetic tree\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryTree\n \n \nType\n.\n\n\nBinaryTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves and per node data\n\n\nsource\n\n\n#\n\n\nPhylo.Branch\n \n \nType\n.\n\n\nBranch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.Nonultrametric\n \n \nType\n.\n\n\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(n::Int,\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Uniform())\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(tiplabels::Vector{String},\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Uniform())\n\n\n\n\n\nThe sampler for non-ultrametric phylogenetic trees of size \nn\n or with tip labels \ntiplabels\n. Generate random trees by calling rand(). Currently only works for \nNamedTree\ns.\n\n\nsource\n\n\n#\n\n\nPhylo.NamedTree\n \n \nType\n.\n\n\nNamedTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves\n\n\nsource\n\n\n#\n\n\nPhylo.addbranch!\n \n \nMethod\n.\n\n\naddbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n,\n \ntarget\n,\n \nlength\n::\nFloat64\n;\n\n           \nbranchname\n \n=\n \n_newbranchlabel\n(\ntree\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.addnode!\n \n \nMethod\n.\n\n\naddnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.addnodes!\n \n \nFunction\n.\n\n\naddnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.branch!\n \n \nFunction\n.\n\n\nbranch!(tree::AbstractTree)\nbranch!(tree::AbstractTree, nodename)\nbranch!(tree::AbstractTree, nodename, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.branchhistory\n \n \nMethod\n.\n\n\nbranchhistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the branch route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.branchroute\n \n \nMethod\n.\n\n\nbranchroute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the branch route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.changesource!\n \n \nMethod\n.\n\n\nchangesource!(tree::AbstractTree, branchname, source)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.changetarget!\n \n \nMethod\n.\n\n\nchangetarget!(tree::AbstractTree, branchname, target)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.clearrootheight!\n \n \nMethod\n.\n\n\nclearrootheight(::AbstractTree)\n\n\n\n\n\nClears the tree's root height record.\n\n\nsource\n\n\n#\n\n\nPhylo.deletebranch!\n \n \nMethod\n.\n\n\ndeletebranch!(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.deletenode!\n \n \nMethod\n.\n\n\ndeletenode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.distance\n \n \nMethod\n.\n\n\ndistance(tree::AbstractTree, node1, node2)\n\n\n\n\n\nDistance between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.distances\n \n \nMethod\n.\n\n\ndistances(tree::AbstractTree)\n\n\n\n\n\nPairwise distances between all leaf nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.getbranch\n \n \nMethod\n.\n\n\ngetbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getbranchnames\n \n \nMethod\n.\n\n\ngetbranchnames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getheight\n \n \nFunction\n.\n\n\ngetheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getinbound\n \n \nFunction\n.\n\n\ngetinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getleafnames\n \n \nMethod\n.\n\n\ngetleafnames(::AbstractTree)\n\n\n\n\n\nretrieve the leaf names from the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getleafrecord\n \n \nMethod\n.\n\n\ngetleafrecord(::AbstractTree, label)\n\n\n\n\n\nretrieve the leaf record for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getlength\n \n \nFunction\n.\n\n\ngetlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnode\n \n \nMethod\n.\n\n\ngetnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnodenames\n \n \nMethod\n.\n\n\ngetnodenames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnoderecord\n \n \nMethod\n.\n\n\ngetnoderecord(::AbstractTree, label)\n\n\n\n\n\nretrieve the node record for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getoutbounds\n \n \nFunction\n.\n\n\ngetoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getrootheight\n \n \nMethod\n.\n\n\ngetrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getsource\n \n \nFunction\n.\n\n\ngetsource(branch::AbstractBranch)\ngetsource(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.gettarget\n \n \nFunction\n.\n\n\ngettarget(branch::AbstractBranch)\ngettarget(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasbranch\n \n \nMethod\n.\n\n\nhasbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasheight\n \n \nFunction\n.\n\n\nhasheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasinbound\n \n \nFunction\n.\n\n\nhasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasnode\n \n \nMethod\n.\n\n\nhasnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasrootheight\n \n \nMethod\n.\n\n\nhasrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.heightstoroot\n \n \nMethod\n.\n\n\nheights(tree::AbstractTree)\n\n\n\n\n\nHeight of all of the leaves of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.heighttoroot\n \n \nMethod\n.\n\n\nheight(tree::AbstractTree, node)\n\n\n\n\n\nHeight of a node of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.indegree\n \n \nFunction\n.\n\n\nindegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isinternal\n \n \nFunction\n.\n\n\nisinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isleaf\n \n \nFunction\n.\n\n\nisleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isroot\n \n \nFunction\n.\n\n\nisroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isunattached\n \n \nFunction\n.\n\n\nisunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.nodehistory\n \n \nMethod\n.\n\n\nnodehistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the node route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.noderoute\n \n \nMethod\n.\n\n\nnoderoute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the node route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.outdegree\n \n \nFunction\n.\n\n\noutdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.setheight!\n \n \nMethod\n.\n\n\nsetheight!(tree::AbstractTree, nodename, height)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.setleafrecord!\n \n \nMethod\n.\n\n\nsetleafrecord(::AbstractTree, label, value)\n\n\n\n\n\nSet the leaf record for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setnoderecord!\n \n \nMethod\n.\n\n\nsetnoderecord(::AbstractTree, label, value)\n\n\n\n\n\nSet the node record for a node of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setrootheight!\n \n \nMethod\n.\n\n\nsetrootheight!(tree::AbstractTree, height)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.validate\n \n \nMethod\n.\n\n\nvalidate(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n\n\nPhylo\n\n\nPhylo.BinaryNode\n\n\nPhylo.BinaryTree\n\n\nPhylo.Branch\n\n\nPhylo.NamedTree\n\n\nPhylo.Nonultrametric\n\n\nPhylo.addbranch!\n\n\nPhylo.addnode!\n\n\nPhylo.addnodes!\n\n\nPhylo.branch!\n\n\nPhylo.branchhistory\n\n\nPhylo.branchroute\n\n\nPhylo.changesource!\n\n\nPhylo.changetarget!\n\n\nPhylo.clearrootheight!\n\n\nPhylo.deletebranch!\n\n\nPhylo.deletenode!\n\n\nPhylo.distance\n\n\nPhylo.distances\n\n\nPhylo.getbranch\n\n\nPhylo.getbranchnames\n\n\nPhylo.getheight\n\n\nPhylo.getinbound\n\n\nPhylo.getleafnames\n\n\nPhylo.getleafrecord\n\n\nPhylo.getlength\n\n\nPhylo.getnode\n\n\nPhylo.getnodenames\n\n\nPhylo.getnoderecord\n\n\nPhylo.getoutbounds\n\n\nPhylo.getrootheight\n\n\nPhylo.getsource\n\n\nPhylo.gettarget\n\n\nPhylo.hasbranch\n\n\nPhylo.hasheight\n\n\nPhylo.hasinbound\n\n\nPhylo.hasnode\n\n\nPhylo.hasrootheight\n\n\nPhylo.heightstoroot\n\n\nPhylo.heighttoroot\n\n\nPhylo.indegree\n\n\nPhylo.isinternal\n\n\nPhylo.isleaf\n\n\nPhylo.isroot\n\n\nPhylo.isunattached\n\n\nPhylo.nodehistory\n\n\nPhylo.noderoute\n\n\nPhylo.outdegree\n\n\nPhylo.setheight!\n\n\nPhylo.setleafrecord!\n\n\nPhylo.setnoderecord!\n\n\nPhylo.setrootheight!\n\n\nPhylo.validate", 
            "title": "Introduction"
        }, 
        {
            "location": "/#phylo", 
            "text": "Package for creating and manipulating phylogenies  Phylo  is a  Julia  package that provides  functionality for generating phylogenetic trees to feed into our  [Diversity][diversity-url] package to calculate phylogenetic  diversity (currently on master, accessible via  Pkg.checkout() ,  but not released). Both are currently under development, so please  [raise an issue][issues-url] if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from  Distributions . For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:  julia   using   Phylo  julia   nu   =   Nonultrametric ( 5 );  julia   rand ( nu )  NamedTree   phylogenetic   tree   with   9   nodes   and   8   branches  Leaf   names :  String [ tip 1 ,   tip 2 ,   tip 3 ,   tip 4 ,   tip 5 ]   The main purpose of this package is to provide a framework for phylogenetics to use in our [Diversity][diversity-url] package, and they will  both  be adapted as appropriate until both are functioning as required.  However, the other important feature that it holds is to allow an interface to R, allowing any existing R functionality to be carried out on julia trees, and trees to be read from disk and written using R helper functions. This is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, for now, if you want to use the R interface you need to do it manually, as below:  julia   using   RCall  julia   include ( joinpath ( Pkg . dir ( Phylo ),   src ,   rcall.jl ));  R   library ( ape )   You can then translate back and forth using  NamedTree  contructors on R  phylo  objects, and  RObject  constructors on julia  NamedTree  types to keep them in Julia or  @rput  to move the object into R:  julia   rt   =   rcall ( : rtree ,   10 )  RCall . RObject { RCall . VecSxp }  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  julia   jt   =   NamedTree ( rt )  NamedTree   phylogenetic   tree   with   19   nodes   and   18   branches  Leaf   names :  String [ t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   t3 ,   t4 ,   t7 ,   t9 ]  julia   @rput   rt ;  julia   @rput   jt ;   # Automatically translates jt back to R  R   jt  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  R   all . equal ( rt ,   jt )   # check no damage in translations  [ 1 ]   TRUE   [issues-url]: https://github.com/richardreeve/Phylo.jl/issues [diversity-url]: https://github.com/richardreeve/Diversity.jl/   Phylo   #  Phylo     Module .  Phylo package  The  Phylo  package provides a standard abstract interface to phylogenetic trees, by defining  AbstractNode ,  AbstractBranch  and  AbstractTree  supertypes, and methods to interface to them. It also provides (through the  Phylo.API  submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.  source  #  Phylo.BinaryNode     Type .  BinaryNode{T}(AbstractVector{T}, AbstractVector{T})  : AbstractNode  A node of strict binary phylogenetic tree  source  #  Phylo.BinaryTree     Type .  BinaryTree  Binary phylogenetic tree object with known leaves and per node data  source  #  Phylo.Branch     Type .  Branch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree  source  #  Phylo.Nonultrametric     Type .  Nonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(n::Int,\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Uniform())\nNonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(tiplabels::Vector{String},\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Uniform())  The sampler for non-ultrametric phylogenetic trees of size  n  or with tip labels  tiplabels . Generate random trees by calling rand(). Currently only works for  NamedTree s.  source  #  Phylo.NamedTree     Type .  NamedTree  Binary phylogenetic tree object with known leaves  source  #  Phylo.addbranch!     Method .  addbranch !( tree :: AbstractTree ,   source ,   target ,   length :: Float64 ; \n            branchname   =   _newbranchlabel ( tree ))   source  #  Phylo.addnode!     Method .  addnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)  source  #  Phylo.addnodes!     Function .  addnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)  source  #  Phylo.branch!     Function .  branch!(tree::AbstractTree)\nbranch!(tree::AbstractTree, nodename)\nbranch!(tree::AbstractTree, nodename, branchname)  source  #  Phylo.branchhistory     Method .  branchhistory(tree::AbstractTree, node)  Find the branch route between a node on a tree and its root  source  #  Phylo.branchroute     Method .  branchroute(tree::AbstractTree, node1, node2)  Find the branch route between two nodes on a tree  source  #  Phylo.changesource!     Method .  changesource!(tree::AbstractTree, branchname, source)  source  #  Phylo.changetarget!     Method .  changetarget!(tree::AbstractTree, branchname, target)  source  #  Phylo.clearrootheight!     Method .  clearrootheight(::AbstractTree)  Clears the tree's root height record.  source  #  Phylo.deletebranch!     Method .  deletebranch!(tree::AbstractTree, branchname)  source  #  Phylo.deletenode!     Method .  deletenode!(tree::AbstractTree, nodename)  source  #  Phylo.distance     Method .  distance(tree::AbstractTree, node1, node2)  Distance between two nodes on a tree  source  #  Phylo.distances     Method .  distances(tree::AbstractTree)  Pairwise distances between all leaf nodes on a tree  source  #  Phylo.getbranch     Method .  getbranch(tree::AbstractTree, branchname)  source  #  Phylo.getbranchnames     Method .  getbranchnames(tree::AbstractTree)  source  #  Phylo.getheight     Function .  getheight(tree::AbstractTree, nodename)  source  #  Phylo.getinbound     Function .  getinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)  source  #  Phylo.getleafnames     Method .  getleafnames(::AbstractTree)  retrieve the leaf names from the tree.  source  #  Phylo.getleafrecord     Method .  getleafrecord(::AbstractTree, label)  retrieve the leaf record for a leaf of the tree.  source  #  Phylo.getlength     Function .  getlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)  source  #  Phylo.getnode     Method .  getnode(tree::AbstractTree, nodename)  source  #  Phylo.getnodenames     Method .  getnodenames(tree::AbstractTree)  source  #  Phylo.getnoderecord     Method .  getnoderecord(::AbstractTree, label)  retrieve the node record for a leaf of the tree.  source  #  Phylo.getoutbounds     Function .  getoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)  source  #  Phylo.getrootheight     Method .  getrootheight(tree::AbstractTree)  source  #  Phylo.getsource     Function .  getsource(branch::AbstractBranch)\ngetsource(tree::AbstractTree, branchname)  source  #  Phylo.gettarget     Function .  gettarget(branch::AbstractBranch)\ngettarget(tree::AbstractTree, branchname)  source  #  Phylo.hasbranch     Method .  hasbranch(tree::AbstractTree, branchname)  source  #  Phylo.hasheight     Function .  hasheight(tree::AbstractTree, nodename)  source  #  Phylo.hasinbound     Function .  hasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)  source  #  Phylo.hasnode     Method .  hasnode(tree::AbstractTree, nodename)  source  #  Phylo.hasrootheight     Method .  hasrootheight(tree::AbstractTree)  source  #  Phylo.heightstoroot     Method .  heights(tree::AbstractTree)  Height of all of the leaves of the tree above the root   source  #  Phylo.heighttoroot     Method .  height(tree::AbstractTree, node)  Height of a node of the tree above the root   source  #  Phylo.indegree     Function .  indegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)  source  #  Phylo.isinternal     Function .  isinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)  source  #  Phylo.isleaf     Function .  isleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)  source  #  Phylo.isroot     Function .  isroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)  source  #  Phylo.isunattached     Function .  isunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)  source  #  Phylo.nodehistory     Method .  nodehistory(tree::AbstractTree, node)  Find the node route between a node on a tree and its root  source  #  Phylo.noderoute     Method .  noderoute(tree::AbstractTree, node1, node2)  Find the node route between two nodes on a tree  source  #  Phylo.outdegree     Function .  outdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)  source  #  Phylo.setheight!     Method .  setheight!(tree::AbstractTree, nodename, height)  source  #  Phylo.setleafrecord!     Method .  setleafrecord(::AbstractTree, label, value)  Set the leaf record for a leaf of the tree.  source  #  Phylo.setnoderecord!     Method .  setnoderecord(::AbstractTree, label, value)  Set the node record for a node of the tree.  source  #  Phylo.setrootheight!     Method .  setrootheight!(tree::AbstractTree, height)  source  #  Phylo.validate     Method .  validate(tree::AbstractTree)  source   Phylo  Phylo.BinaryNode  Phylo.BinaryTree  Phylo.Branch  Phylo.NamedTree  Phylo.Nonultrametric  Phylo.addbranch!  Phylo.addnode!  Phylo.addnodes!  Phylo.branch!  Phylo.branchhistory  Phylo.branchroute  Phylo.changesource!  Phylo.changetarget!  Phylo.clearrootheight!  Phylo.deletebranch!  Phylo.deletenode!  Phylo.distance  Phylo.distances  Phylo.getbranch  Phylo.getbranchnames  Phylo.getheight  Phylo.getinbound  Phylo.getleafnames  Phylo.getleafrecord  Phylo.getlength  Phylo.getnode  Phylo.getnodenames  Phylo.getnoderecord  Phylo.getoutbounds  Phylo.getrootheight  Phylo.getsource  Phylo.gettarget  Phylo.hasbranch  Phylo.hasheight  Phylo.hasinbound  Phylo.hasnode  Phylo.hasrootheight  Phylo.heightstoroot  Phylo.heighttoroot  Phylo.indegree  Phylo.isinternal  Phylo.isleaf  Phylo.isroot  Phylo.isunattached  Phylo.nodehistory  Phylo.noderoute  Phylo.outdegree  Phylo.setheight!  Phylo.setleafrecord!  Phylo.setnoderecord!  Phylo.setrootheight!  Phylo.validate", 
            "title": "Phylo"
        }
    ]
}