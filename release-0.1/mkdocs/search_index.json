{
    "docs": [
        {
            "location": "/", 
            "text": "Phylo\n\n\nPackage for creating and manipulating phylogenies\n\n\nPhylo\n is a \nJulia\n package that provides  functionality for generating phylogenetic trees to feed into our  [Diversity][diversity-url] package to calculate phylogenetic  diversity (currently on master, accessible via \nPkg.checkout()\n,  but not released). Both are currently under development, so please  [raise an issue][issues-url] if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from \nDistributions\n. For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:\n\n\njulia\n \nusing\n \nPhylo\n\n\n\njulia\n \nnu\n \n=\n \nNonultrametric\n(\n5\n);\n\n\n\njulia\n \nrand\n(\nnu\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n9\n \nnodes\n \nand\n \n8\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\ntip 1\n,\n \ntip 2\n,\n \ntip 3\n,\n \ntip 4\n,\n \ntip 5\n]\n\n\n\n\n\n\nThe main purpose of this package is to provide a framework for phylogenetics to use in our [Diversity][diversity-url] package, and they will \nboth\n be adapted as appropriate until both are functioning as required.\n\n\nHowever, the other important feature that it holds is to allow an interface to R, allowing any existing R functionality to be carried out on julia trees, and trees to be read from disk and written using R helper functions. This is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, for now, if you want to use the R interface you need to do it manually, as below:\n\n\njulia\n \nusing\n \nRCall\n\n\n\njulia\n \ninclude\n(\njoinpath\n(\nPkg\n.\ndir\n(\nPhylo\n),\n \nsrc\n,\n \nrcall.jl\n));\n\n\n\nR\n \nlibrary\n(\nape\n)\n\n\n\n\n\n\nYou can then translate back and forth using \nNamedTree\n contructors on R \nphylo\n objects, and \nRObject\n constructors on julia \nNamedTree\n types to keep them in Julia or \n@rput\n to move the object into R:\n\n\njulia\n \nrt\n \n=\n \nrcall\n(\n:\nrtree\n,\n \n10\n)\n\n\nRCall\n.\nRObject\n{\nRCall\n.\nVecSxp\n}\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\njulia\n \njt\n \n=\n \nNamedTree\n(\nrt\n)\n\n\nNamedTree\n \nphylogenetic\n \ntree\n \nwith\n \n19\n \nnodes\n \nand\n \n18\n \nbranches\n\n\nLeaf\n \nnames\n:\n\n\nString\n[\nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \nt3\n,\n \nt4\n,\n \nt7\n,\n \nt9\n]\n\n\n\njulia\n \n@rput\n \nrt\n;\n\n\n\njulia\n \n@rput\n \njt\n;\n \n# Automatically translates jt back to R\n\n\n\nR\n \njt\n\n\n\nPhylogenetic\n \ntree\n \nwith\n \n10\n \ntips\n \nand\n \n9\n \ninternal\n \nnodes\n.\n\n\n\nTip\n \nlabels\n:\n\n    \nt10\n,\n \nt8\n,\n \nt1\n,\n \nt2\n,\n \nt6\n,\n \nt5\n,\n \n...\n\n\n\nRooted\n;\n \nincludes\n \nbranch\n \nlengths\n.\n\n\n\nR\n \nall\n.\nequal\n(\nrt\n,\n \njt\n)\n \n# check no damage in translations\n\n\n[\n1\n]\n \nTRUE\n\n\n\n\n\n\n[issues-url]: https://github.com/richardreeve/Phylo.jl/issues [diversity-url]: https://github.com/richardreeve/Diversity.jl/\n\n\n\n\nPhylo\n\n\n\n\n#\n\n\nPhylo\n \n \nModule\n.\n\n\nPhylo package\n\n\n\n\n\nThe \nPhylo\n package provides a standard abstract interface to phylogenetic trees, by defining \nAbstractNode\n, \nAbstractBranch\n and \nAbstractTree\n supertypes, and methods to interface to them. It also provides (through the \nPhylo.API\n submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryNode\n \n \nType\n.\n\n\nBinaryNode{T}(AbstractVector{T}, AbstractVector{T}) \n: AbstractNode\n\n\n\n\n\nA node of strict binary phylogenetic tree\n\n\nsource\n\n\n#\n\n\nPhylo.BinaryTree\n \n \nType\n.\n\n\nBinaryTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves and per node data\n\n\nsource\n\n\n#\n\n\nPhylo.Branch\n \n \nType\n.\n\n\nBranch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.Nonultrametric\n \n \nType\n.\n\n\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(n::Int,\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Exponential())\nNonultrametric{T \n: AbstractTree,\n               RNG \n: Sampleable}(tiplabels::Vector{String},\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Exponential())\n\n\n\n\n\nThe sampler for non-ultrametric phylogenetic trees of size \nn\n or with tip labels \ntiplabels\n. Generate random trees by calling rand(). Currently only works for \nNamedTree\ns.\n\n\nsource\n\n\n#\n\n\nPhylo.Ultrametric\n \n \nType\n.\n\n\nUltrametric{T \n: AbstractTree,\n            RNG \n: Sampleable}(n::Int,\n                               treetype::Type{T} = NamedTree,\n                               rng::RNG = Exponential())\nUltrametric{T \n: AbstractTree,\n            RNG \n: Sampleable}(tiplabels::Vector{String},\n                               treetype::Type{T} = NamedTree,\n                               rng::RNG = Exponential())\n\n\n\n\n\nThe sampler for ultrametric phylogenetic trees of size \nn\n or with tip labels \ntiplabels\n. Generate random trees by calling rand(). Currently only works for \nNamedTree\ns.\n\n\nsource\n\n\n#\n\n\nPhylo.NamedTree\n \n \nType\n.\n\n\nNamedTree\n\n\n\n\n\nBinary phylogenetic tree object with known leaves\n\n\nsource\n\n\n#\n\n\nPhylo.addbranch!\n \n \nFunction\n.\n\n\naddbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n,\n \ntarget\n[\n,\n \nlength\n::Float64\n]\n;\n\n           \nbranchname\n \n=\n \n_newbranchlabel\n(\ntree\n))\n\n\n\n\n\n\nAdd a branch from \nsource\n to \ntarget\n on \ntree\n.\n\n\nsource\n\n\n#\n\n\nPhylo.addnode!\n \n \nFunction\n.\n\n\naddnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.addnodes!\n \n \nFunction\n.\n\n\naddnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.branch!\n \n \nFunction\n.\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n)\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n;\n \ntarget\n)\n\n\nbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n[\n,\n \nlength\n]\n;\n \ntarget\n,\n \nbranchname\n)\n\n\n\n\n\n\nBranch from a source node \nsource\n and create a target node \ntarget\n.\n\n\nsource\n\n\n#\n\n\nPhylo.branchhistory\n \n \nMethod\n.\n\n\nbranchhistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the branch route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.branchroute\n \n \nMethod\n.\n\n\nbranchroute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the branch route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.changesource!\n \n \nMethod\n.\n\n\nchangesource!(tree::AbstractTree, branchname, source)\n\n\n\n\n\nChange the source node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.changetarget!\n \n \nMethod\n.\n\n\nchangetarget!(tree::AbstractTree, branchname, target)\n\n\n\n\n\nChange the target node for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.clearrootheight!\n \n \nMethod\n.\n\n\nclearrootheight(::AbstractTree)\n\n\n\n\n\nClears the tree's root height record.\n\n\nsource\n\n\n#\n\n\nPhylo.deletebranch!\n \n \nMethod\n.\n\n\ndeletebranch!(tree::AbstractTree, branchname)\n\n\n\n\n\nDelete the branch \nbranchname\n from \ntree\n.\n\n\nsource\n\n\n#\n\n\nPhylo.deletenode!\n \n \nMethod\n.\n\n\ndeletenode!(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.distance\n \n \nMethod\n.\n\n\ndistance(tree::AbstractTree, node1, node2)\n\n\n\n\n\nDistance between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.distances\n \n \nMethod\n.\n\n\ndistances(tree::AbstractTree)\n\n\n\n\n\nPairwise distances between all leaf nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.getancestors\n \n \nMethod\n.\n\n\ngetancestors(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name of all of the nodes that are ancestral to this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getbranch\n \n \nMethod\n.\n\n\ngetbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getbranchnames\n \n \nMethod\n.\n\n\ngetbranchnames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getchildren\n \n \nMethod\n.\n\n\ngetchildren(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name(s) of the child node(s) for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getdescendants\n \n \nMethod\n.\n\n\ngetdescendants(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the names of all of the nodes that descend from this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getheight\n \n \nMethod\n.\n\n\ngetheight(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the height of the node.\n\n\nsource\n\n\n#\n\n\nPhylo.getinbound\n \n \nFunction\n.\n\n\ngetinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nreturn the name of the inbound branch to this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getleafinfo\n \n \nMethod\n.\n\n\ngetleafinfo(::AbstractTree, label)\n\n\n\n\n\nretrieve the leaf info for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getleafnames\n \n \nMethod\n.\n\n\ngetleafnames(::AbstractTree)\n\n\n\n\n\nRetrieve the leaf names from the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getlength\n \n \nFunction\n.\n\n\ngetlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the length of this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.getnode\n \n \nMethod\n.\n\n\ngetnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnodenames\n \n \nMethod\n.\n\n\ngetnodenames(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getnoderecord\n \n \nMethod\n.\n\n\ngetnoderecord(::AbstractTree, label)\n\n\n\n\n\nretrieve the node record for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.getoutbounds\n \n \nFunction\n.\n\n\ngetoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the names of the outbound branches from this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getparent\n \n \nMethod\n.\n\n\ngetparent(tree::AbstractTree, nodename)\n\n\n\n\n\nReturn the name of the parent node for this node.\n\n\nsource\n\n\n#\n\n\nPhylo.getrootheight\n \n \nMethod\n.\n\n\ngetrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.getsource\n \n \nFunction\n.\n\n\ngetsource(branch::AbstractBranch)\ngetsource(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the source node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.gettarget\n \n \nFunction\n.\n\n\ngettarget(branch::AbstractBranch)\ngettarget(tree::AbstractTree, branchname)\n\n\n\n\n\nReturn the target node for this branch.\n\n\nsource\n\n\n#\n\n\nPhylo.hasbranch\n \n \nMethod\n.\n\n\nhasbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasheight\n \n \nFunction\n.\n\n\nhasheight(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have a height defined?\n\n\nsource\n\n\n#\n\n\nPhylo.hasinbound\n \n \nFunction\n.\n\n\nhasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)\n\n\n\n\n\nDoes the node have an inbound connection?\n\n\nsource\n\n\n#\n\n\nPhylo.hasnode\n \n \nMethod\n.\n\n\nhasnode(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.hasrootheight\n \n \nMethod\n.\n\n\nhasrootheight(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.heightstoroot\n \n \nMethod\n.\n\n\nheights(tree::AbstractTree)\n\n\n\n\n\nHeight of all of the leaves of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.heighttoroot\n \n \nMethod\n.\n\n\nheight(tree::AbstractTree, node)\n\n\n\n\n\nHeight of a node of the tree above the root \n\n\nsource\n\n\n#\n\n\nPhylo.indegree\n \n \nFunction\n.\n\n\nindegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isinternal\n \n \nFunction\n.\n\n\nisinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isleaf\n \n \nFunction\n.\n\n\nisleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isroot\n \n \nFunction\n.\n\n\nisroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.isunattached\n \n \nFunction\n.\n\n\nisunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.nodehistory\n \n \nMethod\n.\n\n\nnodehistory(tree::AbstractTree, node)\n\n\n\n\n\nFind the node route between a node on a tree and its root\n\n\nsource\n\n\n#\n\n\nPhylo.noderoute\n \n \nMethod\n.\n\n\nnoderoute(tree::AbstractTree, node1, node2)\n\n\n\n\n\nFind the node route between two nodes on a tree\n\n\nsource\n\n\n#\n\n\nPhylo.outdegree\n \n \nFunction\n.\n\n\noutdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.setheight!\n \n \nMethod\n.\n\n\nsetheight!(tree::AbstractTree, nodename, height)\n\n\n\n\n\nSet the height of the node.\n\n\nsource\n\n\n#\n\n\nPhylo.setleafinfo!\n \n \nMethod\n.\n\n\nsetleafinfo!(::AbstractTree, label, value)\n\n\n\n\n\nSet the leaf info for a leaf of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setnoderecord!\n \n \nMethod\n.\n\n\nsetnoderecord(::AbstractTree, label, value)\n\n\n\n\n\nSet the node record for a node of the tree.\n\n\nsource\n\n\n#\n\n\nPhylo.setrootheight!\n \n \nMethod\n.\n\n\nsetrootheight!(tree::AbstractTree, height)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.validate\n \n \nMethod\n.\n\n\nvalidate(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n\n\nPhylo\n\n\nPhylo.API\n\n\nPhylo.BinaryNode\n\n\nPhylo.BinaryTree\n\n\nPhylo.Branch\n\n\nPhylo.NamedTree\n\n\nPhylo.Nonultrametric\n\n\nPhylo.Ultrametric\n\n\nPhylo.API._addbranch!\n\n\nPhylo.API._addnode!\n\n\nPhylo.API._addnodes!\n\n\nPhylo.API._branch!\n\n\nPhylo.API._deletebranch!\n\n\nPhylo.API._deletenode!\n\n\nPhylo.API._getbranch\n\n\nPhylo.API._getbranches\n\n\nPhylo.API._getbranchnames\n\n\nPhylo.API._getheight\n\n\nPhylo.API._getinbound\n\n\nPhylo.API._getlength\n\n\nPhylo.API._getnode\n\n\nPhylo.API._getnodenames\n\n\nPhylo.API._getnodes\n\n\nPhylo.API._getoutbounds\n\n\nPhylo.API._getrootheight\n\n\nPhylo.API._getsource\n\n\nPhylo.API._gettarget\n\n\nPhylo.API._hasbranch\n\n\nPhylo.API._hasheight\n\n\nPhylo.API._hasinbound\n\n\nPhylo.API._hasinboundspace\n\n\nPhylo.API._hasnode\n\n\nPhylo.API._hasoutboundspace\n\n\nPhylo.API._hasrootheight\n\n\nPhylo.API._indegree\n\n\nPhylo.API._isinternal\n\n\nPhylo.API._isleaf\n\n\nPhylo.API._isroot\n\n\nPhylo.API._isunattached\n\n\nPhylo.API._newbranchlabel\n\n\nPhylo.API._newnodelabel\n\n\nPhylo.API._outdegree\n\n\nPhylo.API._setheight!\n\n\nPhylo.API._setrootheight!\n\n\nPhylo.API._setsource!\n\n\nPhylo.API._settarget!\n\n\nPhylo.API._validate\n\n\nPhylo.addbranch!\n\n\nPhylo.addnode!\n\n\nPhylo.addnodes!\n\n\nPhylo.branch!\n\n\nPhylo.branchhistory\n\n\nPhylo.branchroute\n\n\nPhylo.changesource!\n\n\nPhylo.changetarget!\n\n\nPhylo.clearrootheight!\n\n\nPhylo.deletebranch!\n\n\nPhylo.deletenode!\n\n\nPhylo.distance\n\n\nPhylo.distances\n\n\nPhylo.getancestors\n\n\nPhylo.getbranch\n\n\nPhylo.getbranchnames\n\n\nPhylo.getchildren\n\n\nPhylo.getdescendants\n\n\nPhylo.getheight\n\n\nPhylo.getinbound\n\n\nPhylo.getleafinfo\n\n\nPhylo.getleafnames\n\n\nPhylo.getlength\n\n\nPhylo.getnode\n\n\nPhylo.getnodenames\n\n\nPhylo.getnoderecord\n\n\nPhylo.getoutbounds\n\n\nPhylo.getparent\n\n\nPhylo.getrootheight\n\n\nPhylo.getsource\n\n\nPhylo.gettarget\n\n\nPhylo.hasbranch\n\n\nPhylo.hasheight\n\n\nPhylo.hasinbound\n\n\nPhylo.hasnode\n\n\nPhylo.hasrootheight\n\n\nPhylo.heightstoroot\n\n\nPhylo.heighttoroot\n\n\nPhylo.indegree\n\n\nPhylo.isinternal\n\n\nPhylo.isleaf\n\n\nPhylo.isroot\n\n\nPhylo.isunattached\n\n\nPhylo.nodehistory\n\n\nPhylo.noderoute\n\n\nPhylo.outdegree\n\n\nPhylo.setheight!\n\n\nPhylo.setleafinfo!\n\n\nPhylo.setnoderecord!\n\n\nPhylo.setrootheight!\n\n\nPhylo.validate", 
            "title": "Introduction"
        }, 
        {
            "location": "/#phylo", 
            "text": "Package for creating and manipulating phylogenies  Phylo  is a  Julia  package that provides  functionality for generating phylogenetic trees to feed into our  [Diversity][diversity-url] package to calculate phylogenetic  diversity (currently on master, accessible via  Pkg.checkout() ,  but not released). Both are currently under development, so please  [raise an issue][issues-url] if you find any problems. Currently the  package can be used to make trees manually, and to generate random  trees using the framework from  Distributions . For instance, to  construct a sampler for 5 tip non-ultrametric trees, and then  generate a random tree of that type:  julia   using   Phylo  julia   nu   =   Nonultrametric ( 5 );  julia   rand ( nu )  NamedTree   phylogenetic   tree   with   9   nodes   and   8   branches  Leaf   names :  String [ tip 1 ,   tip 2 ,   tip 3 ,   tip 4 ,   tip 5 ]   The main purpose of this package is to provide a framework for phylogenetics to use in our [Diversity][diversity-url] package, and they will  both  be adapted as appropriate until both are functioning as required.  However, the other important feature that it holds is to allow an interface to R, allowing any existing R functionality to be carried out on julia trees, and trees to be read from disk and written using R helper functions. This is not built into the package as it will make RCall (and R) a dependency, which I wanted to avoid. Instead, for now, if you want to use the R interface you need to do it manually, as below:  julia   using   RCall  julia   include ( joinpath ( Pkg . dir ( Phylo ),   src ,   rcall.jl ));  R   library ( ape )   You can then translate back and forth using  NamedTree  contructors on R  phylo  objects, and  RObject  constructors on julia  NamedTree  types to keep them in Julia or  @rput  to move the object into R:  julia   rt   =   rcall ( : rtree ,   10 )  RCall . RObject { RCall . VecSxp }  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  julia   jt   =   NamedTree ( rt )  NamedTree   phylogenetic   tree   with   19   nodes   and   18   branches  Leaf   names :  String [ t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   t3 ,   t4 ,   t7 ,   t9 ]  julia   @rput   rt ;  julia   @rput   jt ;   # Automatically translates jt back to R  R   jt  Phylogenetic   tree   with   10   tips   and   9   internal   nodes .  Tip   labels : \n     t10 ,   t8 ,   t1 ,   t2 ,   t6 ,   t5 ,   ...  Rooted ;   includes   branch   lengths .  R   all . equal ( rt ,   jt )   # check no damage in translations  [ 1 ]   TRUE   [issues-url]: https://github.com/richardreeve/Phylo.jl/issues [diversity-url]: https://github.com/richardreeve/Diversity.jl/   Phylo   #  Phylo     Module .  Phylo package  The  Phylo  package provides a standard abstract interface to phylogenetic trees, by defining  AbstractNode ,  AbstractBranch  and  AbstractTree  supertypes, and methods to interface to them. It also provides (through the  Phylo.API  submodule) methods to (re)define to write your own phylogenetic type in a way that will interact cleanly with other phylogenetic packages. Finally, it provides a simple phylogenetics type.  source  #  Phylo.BinaryNode     Type .  BinaryNode{T}(AbstractVector{T}, AbstractVector{T})  : AbstractNode  A node of strict binary phylogenetic tree  source  #  Phylo.BinaryTree     Type .  BinaryTree  Binary phylogenetic tree object with known leaves and per node data  source  #  Phylo.Branch     Type .  Branch\n\nA directed branch connecting two AbstractNodes of phylogenetic tree  source  #  Phylo.Nonultrametric     Type .  Nonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(n::Int,\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Exponential())\nNonultrametric{T  : AbstractTree,\n               RNG  : Sampleable}(tiplabels::Vector{String},\n                                  treetype::Type{T} = NamedTree,\n                                  rng::RNG = Exponential())  The sampler for non-ultrametric phylogenetic trees of size  n  or with tip labels  tiplabels . Generate random trees by calling rand(). Currently only works for  NamedTree s.  source  #  Phylo.Ultrametric     Type .  Ultrametric{T  : AbstractTree,\n            RNG  : Sampleable}(n::Int,\n                               treetype::Type{T} = NamedTree,\n                               rng::RNG = Exponential())\nUltrametric{T  : AbstractTree,\n            RNG  : Sampleable}(tiplabels::Vector{String},\n                               treetype::Type{T} = NamedTree,\n                               rng::RNG = Exponential())  The sampler for ultrametric phylogenetic trees of size  n  or with tip labels  tiplabels . Generate random trees by calling rand(). Currently only works for  NamedTree s.  source  #  Phylo.NamedTree     Type .  NamedTree  Binary phylogenetic tree object with known leaves  source  #  Phylo.addbranch!     Function .  addbranch !( tree :: AbstractTree ,   source ,   target [ ,   length ::Float64 ] ; \n            branchname   =   _newbranchlabel ( tree ))   Add a branch from  source  to  target  on  tree .  source  #  Phylo.addnode!     Function .  addnode!(tree::AbstractTree)\naddnode!(tree::AbstractTree, nodename)  source  #  Phylo.addnodes!     Function .  addnodes!(tree::AbstractTree, nodenames::AbstractVector)\naddnodes!(tree::AbstractTree, count::Integer)  source  #  Phylo.branch!     Function .  branch !( tree :: AbstractTree ,   source [ ,   length ] )  branch !( tree :: AbstractTree ,   source [ ,   length ] ;   target )  branch !( tree :: AbstractTree ,   source [ ,   length ] ;   target ,   branchname )   Branch from a source node  source  and create a target node  target .  source  #  Phylo.branchhistory     Method .  branchhistory(tree::AbstractTree, node)  Find the branch route between a node on a tree and its root  source  #  Phylo.branchroute     Method .  branchroute(tree::AbstractTree, node1, node2)  Find the branch route between two nodes on a tree  source  #  Phylo.changesource!     Method .  changesource!(tree::AbstractTree, branchname, source)  Change the source node for this branch.  source  #  Phylo.changetarget!     Method .  changetarget!(tree::AbstractTree, branchname, target)  Change the target node for this node.  source  #  Phylo.clearrootheight!     Method .  clearrootheight(::AbstractTree)  Clears the tree's root height record.  source  #  Phylo.deletebranch!     Method .  deletebranch!(tree::AbstractTree, branchname)  Delete the branch  branchname  from  tree .  source  #  Phylo.deletenode!     Method .  deletenode!(tree::AbstractTree, nodename)  source  #  Phylo.distance     Method .  distance(tree::AbstractTree, node1, node2)  Distance between two nodes on a tree  source  #  Phylo.distances     Method .  distances(tree::AbstractTree)  Pairwise distances between all leaf nodes on a tree  source  #  Phylo.getancestors     Method .  getancestors(tree::AbstractTree, nodename)  Return the name of all of the nodes that are ancestral to this node.  source  #  Phylo.getbranch     Method .  getbranch(tree::AbstractTree, branchname)  source  #  Phylo.getbranchnames     Method .  getbranchnames(tree::AbstractTree)  source  #  Phylo.getchildren     Method .  getchildren(tree::AbstractTree, nodename)  Return the name(s) of the child node(s) for this node.  source  #  Phylo.getdescendants     Method .  getdescendants(tree::AbstractTree, nodename)  Return the names of all of the nodes that descend from this node.  source  #  Phylo.getheight     Method .  getheight(tree::AbstractTree, nodename)  Return the height of the node.  source  #  Phylo.getinbound     Function .  getinbound(node::AbstractNode)\ngetinbound(tree::AbstractTree, nodename)  return the name of the inbound branch to this node.  source  #  Phylo.getleafinfo     Method .  getleafinfo(::AbstractTree, label)  retrieve the leaf info for a leaf of the tree.  source  #  Phylo.getleafnames     Method .  getleafnames(::AbstractTree)  Retrieve the leaf names from the tree.  source  #  Phylo.getlength     Function .  getlength(branch::AbstractBranch)\ngetlength(tree::AbstractTree, branchname)  Return the length of this branch.  source  #  Phylo.getnode     Method .  getnode(tree::AbstractTree, nodename)  source  #  Phylo.getnodenames     Method .  getnodenames(tree::AbstractTree)  source  #  Phylo.getnoderecord     Method .  getnoderecord(::AbstractTree, label)  retrieve the node record for a leaf of the tree.  source  #  Phylo.getoutbounds     Function .  getoutbounds(node::AbstractNode)\ngetoutbounds(tree::AbstractTree, nodename)  Return the names of the outbound branches from this node.  source  #  Phylo.getparent     Method .  getparent(tree::AbstractTree, nodename)  Return the name of the parent node for this node.  source  #  Phylo.getrootheight     Method .  getrootheight(tree::AbstractTree)  source  #  Phylo.getsource     Function .  getsource(branch::AbstractBranch)\ngetsource(tree::AbstractTree, branchname)  Return the source node for this branch.  source  #  Phylo.gettarget     Function .  gettarget(branch::AbstractBranch)\ngettarget(tree::AbstractTree, branchname)  Return the target node for this branch.  source  #  Phylo.hasbranch     Method .  hasbranch(tree::AbstractTree, branchname)  source  #  Phylo.hasheight     Function .  hasheight(tree::AbstractTree, nodename)  Does the node have a height defined?  source  #  Phylo.hasinbound     Function .  hasinbound(node::AbstractNode)\nhasinbound(tree::AbstractTree, nodename)  Does the node have an inbound connection?  source  #  Phylo.hasnode     Method .  hasnode(tree::AbstractTree, nodename)  source  #  Phylo.hasrootheight     Method .  hasrootheight(tree::AbstractTree)  source  #  Phylo.heightstoroot     Method .  heights(tree::AbstractTree)  Height of all of the leaves of the tree above the root   source  #  Phylo.heighttoroot     Method .  height(tree::AbstractTree, node)  Height of a node of the tree above the root   source  #  Phylo.indegree     Function .  indegree(node::AbstractNode)\nindegree(tree::AbstractTree, nodename)  source  #  Phylo.isinternal     Function .  isinternal(node::AbstractNode)\nisinternal(tree::AbstractTree, nodename)  source  #  Phylo.isleaf     Function .  isleaf(node::AbstractNode)\nisleaf(tree::AbstractTree, nodename)  source  #  Phylo.isroot     Function .  isroot(node::AbstractNode)\nisroot(tree::AbstractTree, nodename)  source  #  Phylo.isunattached     Function .  isunattached(node::AbstractNode)\nisunattached(tree::AbstractTree, nodename)  source  #  Phylo.nodehistory     Method .  nodehistory(tree::AbstractTree, node)  Find the node route between a node on a tree and its root  source  #  Phylo.noderoute     Method .  noderoute(tree::AbstractTree, node1, node2)  Find the node route between two nodes on a tree  source  #  Phylo.outdegree     Function .  outdegree(node::AbstractNode)\noutdegree(tree::AbstractTree, nodename)  source  #  Phylo.setheight!     Method .  setheight!(tree::AbstractTree, nodename, height)  Set the height of the node.  source  #  Phylo.setleafinfo!     Method .  setleafinfo!(::AbstractTree, label, value)  Set the leaf info for a leaf of the tree.  source  #  Phylo.setnoderecord!     Method .  setnoderecord(::AbstractTree, label, value)  Set the node record for a node of the tree.  source  #  Phylo.setrootheight!     Method .  setrootheight!(tree::AbstractTree, height)  source  #  Phylo.validate     Method .  validate(tree::AbstractTree)  source   Phylo  Phylo.API  Phylo.BinaryNode  Phylo.BinaryTree  Phylo.Branch  Phylo.NamedTree  Phylo.Nonultrametric  Phylo.Ultrametric  Phylo.API._addbranch!  Phylo.API._addnode!  Phylo.API._addnodes!  Phylo.API._branch!  Phylo.API._deletebranch!  Phylo.API._deletenode!  Phylo.API._getbranch  Phylo.API._getbranches  Phylo.API._getbranchnames  Phylo.API._getheight  Phylo.API._getinbound  Phylo.API._getlength  Phylo.API._getnode  Phylo.API._getnodenames  Phylo.API._getnodes  Phylo.API._getoutbounds  Phylo.API._getrootheight  Phylo.API._getsource  Phylo.API._gettarget  Phylo.API._hasbranch  Phylo.API._hasheight  Phylo.API._hasinbound  Phylo.API._hasinboundspace  Phylo.API._hasnode  Phylo.API._hasoutboundspace  Phylo.API._hasrootheight  Phylo.API._indegree  Phylo.API._isinternal  Phylo.API._isleaf  Phylo.API._isroot  Phylo.API._isunattached  Phylo.API._newbranchlabel  Phylo.API._newnodelabel  Phylo.API._outdegree  Phylo.API._setheight!  Phylo.API._setrootheight!  Phylo.API._setsource!  Phylo.API._settarget!  Phylo.API._validate  Phylo.addbranch!  Phylo.addnode!  Phylo.addnodes!  Phylo.branch!  Phylo.branchhistory  Phylo.branchroute  Phylo.changesource!  Phylo.changetarget!  Phylo.clearrootheight!  Phylo.deletebranch!  Phylo.deletenode!  Phylo.distance  Phylo.distances  Phylo.getancestors  Phylo.getbranch  Phylo.getbranchnames  Phylo.getchildren  Phylo.getdescendants  Phylo.getheight  Phylo.getinbound  Phylo.getleafinfo  Phylo.getleafnames  Phylo.getlength  Phylo.getnode  Phylo.getnodenames  Phylo.getnoderecord  Phylo.getoutbounds  Phylo.getparent  Phylo.getrootheight  Phylo.getsource  Phylo.gettarget  Phylo.hasbranch  Phylo.hasheight  Phylo.hasinbound  Phylo.hasnode  Phylo.hasrootheight  Phylo.heightstoroot  Phylo.heighttoroot  Phylo.indegree  Phylo.isinternal  Phylo.isleaf  Phylo.isroot  Phylo.isunattached  Phylo.nodehistory  Phylo.noderoute  Phylo.outdegree  Phylo.setheight!  Phylo.setleafinfo!  Phylo.setnoderecord!  Phylo.setrootheight!  Phylo.validate", 
            "title": "Phylo"
        }, 
        {
            "location": "/api/", 
            "text": "The \nPhylo.API\n submodule provides the API that must be extended for new \nAbstractTree\n, \nAbstractNode\n and \nAbstractBranch\n subtypes.\n\n\n\n\nUsage\n\n\nProviding additional code to extend the functionality of the system is simple:\n\n\nusing\n \nPhylo\n\n\nimportall\n \nPhylo\n.\nAPI\n\n\n\ntype\n \nSimplestTree\n \n:\n \nAbstractTree\n{\nInt\n,\n \nInt\n}\n\n    \nnodes\n::\nOrderedDict\n{\nInt\n,\n \nBinaryNode\n{\nInt\n}}\n\n    \nbranches\n::\nDict\n{\nInt\n,\n \nBranch\n{\nInt\n}}\n\n\nend\n\n\n\nfunction\n \n_addnode\n!\n(\ntree\n::\nSimplestTree\n,\n \nnum\n)\n\n    \n_setnode\n!\n(\ntree\n,\n \nnum\n,\n \nBinaryNode\n{\nInt\n}())\n\n    \nreturn\n \nnum\n\n\nend\n\n\n\n\n\n\ncreates a new \nSimplestTree\n type (a subtype of \nAbstractTree\n) and extends \nPhylo.API._addnode!()\n (and therefore the directly accessible \naddnode!()\n interface) to handle the \nSimplestTree\n subtype of \nAbstractTree\n. See docs here to see which \nPhylo.API\n functions have to be extended for any new subtype, and which have default implementations.\n\n\n\n\nPhylo\n\n\n\n\n#\n\n\nPhylo.API\n \n \nModule\n.\n\n\nPhylo.API submodule\n\n\n\n\n\nThe \nPhylo.API\n submodule should be \nimport[all]\ned if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addbranch!\n \n \nFunction\n.\n\n\n_addbranch\n!(\ntree\n::\nAbstractTree\n,\n \nsource\n,\n \ntarget\n;\n\n            \nlength\n::\nFloat64\n \n=\n \nNaN\n,\n\n            \nbranchname\n \n=\n \n_newbranchlabel\n(\ntree\n))\n\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addnode!\n \n \nFunction\n.\n\n\n_addnode!(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._addnodes!\n \n \nFunction\n.\n\n\n_addnodes!(tree::AbstractTree, nodenames::AbstractVector)\n_addnodes!(tree:AbstractTree, count::Integer)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._branch!\n \n \nMethod\n.\n\n\n_branch!(tree::AbstractTree, source, length::Float64, target, branchname)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._deletebranch!\n \n \nFunction\n.\n\n\n_deletebranch!(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._deletenode!\n \n \nFunction\n.\n\n\n_deletenode!(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranch\n \n \nFunction\n.\n\n\n_getbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranches\n \n \nFunction\n.\n\n\n_getbranches(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getbranchnames\n \n \nFunction\n.\n\n\n_getbranchnames(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getheight\n \n \nMethod\n.\n\n\n_getheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._getinbound\n \n \nFunction\n.\n\n\n_getinbound(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getlength\n \n \nFunction\n.\n\n\n_getlength\n\n\n\n\n\nMust be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnode\n \n \nFunction\n.\n\n\n_getnode(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnodenames\n \n \nFunction\n.\n\n\n_getnodenames(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getnodes\n \n \nFunction\n.\n\n\n_getnodes(tree::AbstractTree)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getoutbounds\n \n \nFunction\n.\n\n\n_getoutbounds(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._getrootheight\n \n \nMethod\n.\n\n\n_getrootheight(::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._getsource\n \n \nFunction\n.\n\n\n_getsource\n\n\n\n\n\nMust be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._gettarget\n \n \nFunction\n.\n\n\n_gettarget\n\n\n\n\n\nMust be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasbranch\n \n \nFunction\n.\n\n\n_hasbranch(tree::AbstractTree, branchname)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasheight\n \n \nMethod\n.\n\n\n_hasheight(tree::AbstractTree, nodename)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasinbound\n \n \nFunction\n.\n\n\n_hasinbound(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasinboundspace\n \n \nMethod\n.\n\n\n_hasinboundspace(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasnode\n \n \nFunction\n.\n\n\n_hasnode(tree::AbstractTree, nodename)\n\n\n\n\n\nMust be implemented for any AbstractTree subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasoutboundspace\n \n \nMethod\n.\n\n\n_hasoutboundspace(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._hasrootheight\n \n \nMethod\n.\n\n\n_hasrootheight(::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._indegree\n \n \nMethod\n.\n\n\n_indegree(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isinternal\n \n \nMethod\n.\n\n\n_isinternal(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isleaf\n \n \nMethod\n.\n\n\n_isleaf(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isroot\n \n \nMethod\n.\n\n\n_isroot(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._isunattached\n \n \nMethod\n.\n\n\n_isunattached(node::AbstractNode)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._newbranchlabel\n \n \nFunction\n.\n\n\n_newbranchlabel(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._newnodelabel\n \n \nFunction\n.\n\n\n_newnodelabel(tree::AbstractTree)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._outdegree\n \n \nFunction\n.\n\n\n_outdegree(node::AbstractNode)\n\n\n\n\n\nMust be implemented for any AbstractNode subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._setheight!\n \n \nMethod\n.\n\n\n_setheight!(::AbstractTree, nodename, value)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._setrootheight!\n \n \nMethod\n.\n\n\n_setrootheight!(::AbstractTree, value)\n\n\n\n\n\nsource\n\n\n#\n\n\nPhylo.API._setsource!\n \n \nFunction\n.\n\n\n_setsource!\n\n\n\n\n\nMust be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._settarget!\n \n \nFunction\n.\n\n\n_settarget!\n\n\n\n\n\nMust be implemented for any AbstractBranch subtype.\n\n\nsource\n\n\n#\n\n\nPhylo.API._validate\n \n \nMethod\n.\n\n\n_validate(::AbstractTree)\n\n\n\n\n\nsource\n\n\n\n\nPhylo\n\n\nPhylo.API\n\n\nPhylo.BinaryNode\n\n\nPhylo.BinaryTree\n\n\nPhylo.Branch\n\n\nPhylo.NamedTree\n\n\nPhylo.Nonultrametric\n\n\nPhylo.Ultrametric\n\n\nPhylo.API._addbranch!\n\n\nPhylo.API._addnode!\n\n\nPhylo.API._addnodes!\n\n\nPhylo.API._branch!\n\n\nPhylo.API._deletebranch!\n\n\nPhylo.API._deletenode!\n\n\nPhylo.API._getbranch\n\n\nPhylo.API._getbranches\n\n\nPhylo.API._getbranchnames\n\n\nPhylo.API._getheight\n\n\nPhylo.API._getinbound\n\n\nPhylo.API._getlength\n\n\nPhylo.API._getnode\n\n\nPhylo.API._getnodenames\n\n\nPhylo.API._getnodes\n\n\nPhylo.API._getoutbounds\n\n\nPhylo.API._getrootheight\n\n\nPhylo.API._getsource\n\n\nPhylo.API._gettarget\n\n\nPhylo.API._hasbranch\n\n\nPhylo.API._hasheight\n\n\nPhylo.API._hasinbound\n\n\nPhylo.API._hasinboundspace\n\n\nPhylo.API._hasnode\n\n\nPhylo.API._hasoutboundspace\n\n\nPhylo.API._hasrootheight\n\n\nPhylo.API._indegree\n\n\nPhylo.API._isinternal\n\n\nPhylo.API._isleaf\n\n\nPhylo.API._isroot\n\n\nPhylo.API._isunattached\n\n\nPhylo.API._newbranchlabel\n\n\nPhylo.API._newnodelabel\n\n\nPhylo.API._outdegree\n\n\nPhylo.API._setheight!\n\n\nPhylo.API._setrootheight!\n\n\nPhylo.API._setsource!\n\n\nPhylo.API._settarget!\n\n\nPhylo.API._validate\n\n\nPhylo.addbranch!\n\n\nPhylo.addnode!\n\n\nPhylo.addnodes!\n\n\nPhylo.branch!\n\n\nPhylo.branchhistory\n\n\nPhylo.branchroute\n\n\nPhylo.changesource!\n\n\nPhylo.changetarget!\n\n\nPhylo.clearrootheight!\n\n\nPhylo.deletebranch!\n\n\nPhylo.deletenode!\n\n\nPhylo.distance\n\n\nPhylo.distances\n\n\nPhylo.getancestors\n\n\nPhylo.getbranch\n\n\nPhylo.getbranchnames\n\n\nPhylo.getchildren\n\n\nPhylo.getdescendants\n\n\nPhylo.getheight\n\n\nPhylo.getinbound\n\n\nPhylo.getleafinfo\n\n\nPhylo.getleafnames\n\n\nPhylo.getlength\n\n\nPhylo.getnode\n\n\nPhylo.getnodenames\n\n\nPhylo.getnoderecord\n\n\nPhylo.getoutbounds\n\n\nPhylo.getparent\n\n\nPhylo.getrootheight\n\n\nPhylo.getsource\n\n\nPhylo.gettarget\n\n\nPhylo.hasbranch\n\n\nPhylo.hasheight\n\n\nPhylo.hasinbound\n\n\nPhylo.hasnode\n\n\nPhylo.hasrootheight\n\n\nPhylo.heightstoroot\n\n\nPhylo.heighttoroot\n\n\nPhylo.indegree\n\n\nPhylo.isinternal\n\n\nPhylo.isleaf\n\n\nPhylo.isroot\n\n\nPhylo.isunattached\n\n\nPhylo.nodehistory\n\n\nPhylo.noderoute\n\n\nPhylo.outdegree\n\n\nPhylo.setheight!\n\n\nPhylo.setleafinfo!\n\n\nPhylo.setnoderecord!\n\n\nPhylo.setrootheight!\n\n\nPhylo.validate", 
            "title": "API"
        }, 
        {
            "location": "/api/#usage", 
            "text": "Providing additional code to extend the functionality of the system is simple:  using   Phylo  importall   Phylo . API  type   SimplestTree   :   AbstractTree { Int ,   Int } \n     nodes :: OrderedDict { Int ,   BinaryNode { Int }} \n     branches :: Dict { Int ,   Branch { Int }}  end  function   _addnode ! ( tree :: SimplestTree ,   num ) \n     _setnode ! ( tree ,   num ,   BinaryNode { Int }()) \n     return   num  end   creates a new  SimplestTree  type (a subtype of  AbstractTree ) and extends  Phylo.API._addnode!()  (and therefore the directly accessible  addnode!()  interface) to handle the  SimplestTree  subtype of  AbstractTree . See docs here to see which  Phylo.API  functions have to be extended for any new subtype, and which have default implementations.   Phylo   #  Phylo.API     Module .  Phylo.API submodule  The  Phylo.API  submodule should be  import[all] ed if you want to create a new phylogeny, node or branch subtype. Otherwise it can be ignored.  source  #  Phylo.API._addbranch!     Function .  _addbranch !( tree :: AbstractTree ,   source ,   target ; \n             length :: Float64   =   NaN , \n             branchname   =   _newbranchlabel ( tree ))   Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._addnode!     Function .  _addnode!(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._addnodes!     Function .  _addnodes!(tree::AbstractTree, nodenames::AbstractVector)\n_addnodes!(tree:AbstractTree, count::Integer)  source  #  Phylo.API._branch!     Method .  _branch!(tree::AbstractTree, source, length::Float64, target, branchname)  source  #  Phylo.API._deletebranch!     Function .  _deletebranch!(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._deletenode!     Function .  _deletenode!(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getbranch     Function .  _getbranch(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getbranches     Function .  _getbranches(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getbranchnames     Function .  _getbranchnames(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getheight     Method .  _getheight(tree::AbstractTree, nodename)  source  #  Phylo.API._getinbound     Function .  _getinbound(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._getlength     Function .  _getlength  Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._getnode     Function .  _getnode(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getnodenames     Function .  _getnodenames(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getnodes     Function .  _getnodes(tree::AbstractTree)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._getoutbounds     Function .  _getoutbounds(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._getrootheight     Method .  _getrootheight(::AbstractTree)  source  #  Phylo.API._getsource     Function .  _getsource  Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._gettarget     Function .  _gettarget  Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._hasbranch     Function .  _hasbranch(tree::AbstractTree, branchname)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._hasheight     Method .  _hasheight(tree::AbstractTree, nodename)  source  #  Phylo.API._hasinbound     Function .  _hasinbound(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._hasinboundspace     Method .  _hasinboundspace(node::AbstractNode)  source  #  Phylo.API._hasnode     Function .  _hasnode(tree::AbstractTree, nodename)  Must be implemented for any AbstractTree subtype.  source  #  Phylo.API._hasoutboundspace     Method .  _hasoutboundspace(node::AbstractNode)  source  #  Phylo.API._hasrootheight     Method .  _hasrootheight(::AbstractTree)  source  #  Phylo.API._indegree     Method .  _indegree(node::AbstractNode)  source  #  Phylo.API._isinternal     Method .  _isinternal(node::AbstractNode)  source  #  Phylo.API._isleaf     Method .  _isleaf(node::AbstractNode)  source  #  Phylo.API._isroot     Method .  _isroot(node::AbstractNode)  source  #  Phylo.API._isunattached     Method .  _isunattached(node::AbstractNode)  source  #  Phylo.API._newbranchlabel     Function .  _newbranchlabel(tree::AbstractTree)  source  #  Phylo.API._newnodelabel     Function .  _newnodelabel(tree::AbstractTree)  source  #  Phylo.API._outdegree     Function .  _outdegree(node::AbstractNode)  Must be implemented for any AbstractNode subtype.  source  #  Phylo.API._setheight!     Method .  _setheight!(::AbstractTree, nodename, value)  source  #  Phylo.API._setrootheight!     Method .  _setrootheight!(::AbstractTree, value)  source  #  Phylo.API._setsource!     Function .  _setsource!  Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._settarget!     Function .  _settarget!  Must be implemented for any AbstractBranch subtype.  source  #  Phylo.API._validate     Method .  _validate(::AbstractTree)  source   Phylo  Phylo.API  Phylo.BinaryNode  Phylo.BinaryTree  Phylo.Branch  Phylo.NamedTree  Phylo.Nonultrametric  Phylo.Ultrametric  Phylo.API._addbranch!  Phylo.API._addnode!  Phylo.API._addnodes!  Phylo.API._branch!  Phylo.API._deletebranch!  Phylo.API._deletenode!  Phylo.API._getbranch  Phylo.API._getbranches  Phylo.API._getbranchnames  Phylo.API._getheight  Phylo.API._getinbound  Phylo.API._getlength  Phylo.API._getnode  Phylo.API._getnodenames  Phylo.API._getnodes  Phylo.API._getoutbounds  Phylo.API._getrootheight  Phylo.API._getsource  Phylo.API._gettarget  Phylo.API._hasbranch  Phylo.API._hasheight  Phylo.API._hasinbound  Phylo.API._hasinboundspace  Phylo.API._hasnode  Phylo.API._hasoutboundspace  Phylo.API._hasrootheight  Phylo.API._indegree  Phylo.API._isinternal  Phylo.API._isleaf  Phylo.API._isroot  Phylo.API._isunattached  Phylo.API._newbranchlabel  Phylo.API._newnodelabel  Phylo.API._outdegree  Phylo.API._setheight!  Phylo.API._setrootheight!  Phylo.API._setsource!  Phylo.API._settarget!  Phylo.API._validate  Phylo.addbranch!  Phylo.addnode!  Phylo.addnodes!  Phylo.branch!  Phylo.branchhistory  Phylo.branchroute  Phylo.changesource!  Phylo.changetarget!  Phylo.clearrootheight!  Phylo.deletebranch!  Phylo.deletenode!  Phylo.distance  Phylo.distances  Phylo.getancestors  Phylo.getbranch  Phylo.getbranchnames  Phylo.getchildren  Phylo.getdescendants  Phylo.getheight  Phylo.getinbound  Phylo.getleafinfo  Phylo.getleafnames  Phylo.getlength  Phylo.getnode  Phylo.getnodenames  Phylo.getnoderecord  Phylo.getoutbounds  Phylo.getparent  Phylo.getrootheight  Phylo.getsource  Phylo.gettarget  Phylo.hasbranch  Phylo.hasheight  Phylo.hasinbound  Phylo.hasnode  Phylo.hasrootheight  Phylo.heightstoroot  Phylo.heighttoroot  Phylo.indegree  Phylo.isinternal  Phylo.isleaf  Phylo.isroot  Phylo.isunattached  Phylo.nodehistory  Phylo.noderoute  Phylo.outdegree  Phylo.setheight!  Phylo.setleafinfo!  Phylo.setnoderecord!  Phylo.setrootheight!  Phylo.validate", 
            "title": "Usage"
        }
    ]
}